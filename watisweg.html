<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>Welk cijfer mist?</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root {
      --bg-top: #f4f1ff;
      --bg-bottom: #fef6e9;
      --card-bg: #ffffff;
      --card-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
      --accent-soft: #ffe0b2;
      --accent-strong: #ff8a65;
      --scan-border-neutral: rgba(255, 255, 255, 0.8);
      --scan-border-scan: rgba(255, 255, 255, 0.9);
      --scan-border-good: #4caf50;
      --scan-border-bad: #e53935;
      --scan-bg-neutral: rgba(255, 255, 255, 0.12);
      --scan-bg-scan: rgba(255, 255, 255, 0.22);
      --scan-bg-good: rgba(76, 175, 80, 0.18);
      --scan-bg-bad: rgba(229, 57, 53, 0.18);
      --text-main: #333333;
      --text-soft: #666666;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom));
      color: var(--text-main);
      display: flex;
      justify-content: center;
      align-items: stretch;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }

    .game {
      width: 100%;
      max-width: 900px;
      min-height: 100vh;
      padding: clamp(12px, 3vh, 24px);
      display: flex;
      flex-direction: column;
      gap: clamp(12px, 2vh, 16px);
    }

    .game-header {
      flex: 0 0 auto;
      display: flex;
      justify-content: center;
      align-items: center;
      padding-top: env(safe-area-inset-top);
    }

    .title-badge {
      background: rgba(255, 255, 255, 0.65);
      border-radius: 999px;
      padding: 8px 18px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
    }

    .title-icon {
      font-size: 1.4rem;
    }

    .title-text {
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      white-space: nowrap;
    }

    .game-main {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: clamp(16px, 3vh, 24px);
    }

    .number-row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: clamp(16px, 4vw, 32px);
      width: 100%;
      max-width: 520px;
    }

    .number-slot {
      flex: 0 0 auto;
      width: min(22vw, 110px);
      aspect-ratio: 1 / 1;
      background: var(--card-bg);
      border-radius: 28px;
      box-shadow: var(--card-shadow);
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: min(16vw, 72px);
      font-weight: 700;
      color: var(--text-main);
      position: relative;
      transition: transform 0.18s ease-out, box-shadow 0.18s ease-out,
                  background 0.18s ease-out, border-color 0.18s ease-out;
      border: 4px solid transparent;
    }

    .number-slot span {
      display: block;
      transform: translateY(4px);
    }

    .number-slot.missing {
      background: var(--accent-soft);
      border-style: dashed;
      border-color: rgba(255, 138, 101, 0.5);
      color: var(--accent-strong);
    }

    .number-slot.correct-pop {
      animation: pop 0.35s ease-out;
    }

    .number-row.shake {
      animation: shake 0.35s ease-out;
    }

    @keyframes pop {
      0% { transform: scale(1); }
      40% { transform: scale(1.08); }
      100% { transform: scale(1); }
    }

    @keyframes shake {
      0% { transform: translateX(0); }
      20% { transform: translateX(-6px); }
      40% { transform: translateX(6px); }
      60% { transform: translateX(-4px); }
      80% { transform: translateX(4px); }
      100% { transform: translateX(0); }
    }

    .feedback {
      min-height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.4rem;
    }

    .game-footer {
      flex: 0 0 auto;
      padding-bottom: env(safe-area-inset-bottom);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .scan-label {
      font-size: 0.95rem;
      text-align: center;
      color: var(--text-soft);
      opacity: 0.9;
    }

    .scan-area {
      margin-top: 4px;
      border-radius: 28px;
      border-width: 4px;
      border-style: dashed;
      border-color: var(--scan-border-neutral);
      background: var(--scan-bg-neutral);
      min-height: 28vh;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.12);
      transition:
        border-color 0.18s ease-out,
        background 0.18s ease-out,
        box-shadow 0.18s ease-out,
        transform 0.12s ease-out;
      position: relative;
      overflow: hidden;
    }

    .scan-area-inner {
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      pointer-events: none;
    }

    .scan-icon {
      font-size: 2.2rem;
    }

    .scan-text {
      font-size: 1.05rem;
      color: var(--text-soft);
    }

    .scan-hint {
      font-size: 0.85rem;
      color: rgba(0, 0, 0, 0.48);
    }

    /* scan states */
    .scan-area.state-neutral {
      border-style: dashed;
      border-color: var(--scan-border-neutral);
      background: var(--scan-bg-neutral);
      transform: translateY(0);
    }

    .scan-area.state-scanning {
      border-style: solid;
      border-color: var(--scan-border-scan);
      background: var(--scan-bg-scan);
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.16);
      transform: translateY(-2px);
    }

    .scan-area.state-correct {
      border-style: solid;
      border-color: var(--scan-border-good);
      background: var(--scan-bg-good);
      box-shadow: 0 12px 30px rgba(76, 175, 80, 0.35);
      transform: translateY(-2px);
    }

    .scan-area.state-wrong {
      border-style: solid;
      border-color: var(--scan-border-bad);
      background: var(--scan-bg-bad);
      box-shadow: 0 12px 30px rgba(229, 57, 53, 0.35);
      transform: translateY(-2px);
    }

    @media (max-width: 600px) {
      .title-text {
        font-size: 0.9rem;
      }
      .number-slot {
        width: min(24vw, 96px);
      }
    }
  </style>
</head>
<body>
  <div class="game">
    <header class="game-header">
      <div class="title-badge">
        <span class="title-icon">üîç</span>
        <span class="title-text">Welk cijfer mist?</span>
      </div>
    </header>

    <main class="game-main">
      <div class="number-row" id="number-row">
        <div class="number-slot" data-index="0">
          <span class="number-text">1</span>
        </div>
        <div class="number-slot missing" data-index="1">
          <span class="number-text">?</span>
        </div>
        <div class="number-slot" data-index="2">
          <span class="number-text">3</span>
        </div>
      </div>

      <div class="feedback" id="feedback" aria-hidden="true"></div>
    </main>

    <footer class="game-footer">
      <div class="scan-label">Leg het houten cijfer in het vak.</div>
      <div class="scan-area state-neutral" id="scan-area">
        <div class="scan-area-inner">
          <div class="scan-icon">üî¢</div>
          <div class="scan-text">Scan-zone</div>
          <div class="scan-hint">Alle puntjes in het vak.</div>
        </div>
      </div>
    </footer>
  </div>

  <script>
    /* ================================
       MARBOTIC HERKENNINGSMODULE
       (ongewijzigd in logica)
       ================================ */

    const DIGIT_ORDER = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

    let calibration = null;            // gevulde kalibratie op basis van calibration.json
    let classificationStats = null;    // drempelwaarden voor herkenning
    let expectedTouchPoints = 3;       // standaard drie contactpunten

    /**
     * Aanroep na het laden van calibration.json
     *
     * Voorbeeld:
     * fetch("calibration.json")
     *   .then(r => r.json())
     *   .then(data => initCalibration(data));
     */
    function initCalibration(calibrationData) {
      if (!calibrationData || typeof calibrationData !== "object") {
        calibration = null;
        classificationStats = null;
        expectedTouchPoints = 3;
        return;
      }

      if (typeof calibrationData.expectedTouchPoints === "number") {
        expectedTouchPoints = calibrationData.expectedTouchPoints;
      } else {
        expectedTouchPoints = 3;
      }

      calibration = buildCalibrationFromData(calibrationData);
      recomputeClassificationStats();
    }

    /**
     * Zet de ruwe JSON structuur om in een intern calibration object
     * met per sample vooraf berekende features.
     *
     * Verwachte JSON vorm:
     * {
     *   "expectedTouchPoints": 3,
     *   "0": { "digit": 0, "samples": [ { "points": [ {x,y}, {x,y}, {x,y} ] }, ... ] },
     *   "1": { ... },
     *   ...
     *   "9": { ... }
     * }
     */
    function buildCalibrationFromData(data) {
      const obj = {};

      // basisstructuur
      DIGIT_ORDER.forEach(function (d) {
        obj[String(d)] = {
          digit: d,
          samples: []
        };
      });

      // samples per cijfer inlezen
      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        const entry = data[key];
        if (!entry || !Array.isArray(entry.samples)) return;

        entry.samples.forEach(function (s) {
          if (!s || !Array.isArray(s.points) || s.points.length !== 3) return;

          const pts = s.points.map(function (p) {
            return { x: Number(p.x), y: Number(p.y) };
          });

          const features = computeFeatures(pts);
          obj[key].samples.push({
            points: pts,
            features: features
          });
        });
      });

      return obj;
    }

    /**
     * Berekent kenmerken uit drie punten:
     * driehoeksverhoudingen, ori√´ntatie, hoek, genormeerde posities en aspect ratio.
     * Levert ook een gewogen featurevector op voor afstandsvergelijking.
     */
    function computeFeatures(points) {
      if (!points || points.length !== 3) {
        return {
          sides: [0, 0, 0],
          orientation: 0,
          cosAngle: 0,
          centroid: { x: 0, y: 0 },
          yNorm: [0, 0, 0],
          xPattern: [0, 0, 0],
          aspect: 0,
          vector: [0, 0, 0]
        };
      }

      const p0 = points[0];
      const p1 = points[1];
      const p2 = points[2];

      const centroidRaw = {
        x: (p0.x + p1.x + p2.x) / 3,
        y: (p0.y + p1.y + p2.y) / 3
      };

      // isoPoints zijn punten rond de oorsprong, geschaald op max afstand
      const isoPoints = [p0, p1, p2].map(function (p) {
        const dx = p.x - centroidRaw.x;
        const dy = p.y - centroidRaw.y;
        return { x: dx, y: dy };
      });

      let maxDist = 0;
      for (let i = 0; i < isoPoints.length; i++) {
        const q = isoPoints[i];
        const d = Math.sqrt(q.x * q.x + q.y * q.y);
        if (d > maxDist) maxDist = d;
      }
      if (maxDist < 1e-6) maxDist = 1;

      for (let i = 0; i < isoPoints.length; i++) {
        isoPoints[i].x /= maxDist;
        isoPoints[i].y /= maxDist;
      }

      function dist(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.sqrt(dx * dx + dy * dy);
      }

      const L01 = dist(isoPoints[0], isoPoints[1]);
      const L12 = dist(isoPoints[1], isoPoints[2]);
      const L20 = dist(isoPoints[2], isoPoints[0]);

      // zijden, klein naar groot, genormeerd op de langste zijde
      const sides = [
        { len: L01, i: 0, j: 1 },
        { len: L12, i: 1, j: 2 },
        { len: L20, i: 2, j: 0 }
      ];
      const maxSideLen = Math.max(L01, L12, L20) || 1;
      const sidesNormSorted = sides
        .slice()
        .sort(function (a, b) {
          return a.len - b.len;
        })
        .map(function (s) {
          return s.len / maxSideLen;
        });

      // grootste zijde vinden om ori√´ntatie en hoek te bepalen
      const largest = sides
        .slice()
        .sort(function (a, b) {
          return a.len - b.len;
        })[2];

      const A = isoPoints[largest.i];
      const B = isoPoints[largest.j];
      const CIndex = 3 - largest.i - largest.j;
      const C = isoPoints[CIndex];

      function orientationVal(a, b, c) {
        const value =
          (b.x - a.x) * (c.y - a.y) -
          (b.y - a.y) * (c.x - a.x);
        if (value > 0) return 1;
        if (value < 0) return -1;
        return 0;
      }

      const orientation = orientationVal(A, B, C);

      // hoek bij punt C via cosinusregel
      const AC = dist(A, C);
      const BC = dist(B, C);
      const AB = largest.len;
      const AC2 = AC * AC;
      const BC2 = BC * BC;
      const AB2 = AB * AB;
      let cosAngle = 0;
      const denom = 2 * AC * BC;
      if (denom > 1e-6) {
        cosAngle = (AC2 + BC2 - AB2) / denom;
      }

      // bounding box van de drie punten in het echte scherm
      let minX = Math.min(p0.x, p1.x, p2.x);
      let maxX = Math.max(p0.x, p1.x, p2.x);
      let minY = Math.min(p0.y, p1.y, p2.y);
      let maxY = Math.max(p0.y, p1.y, p2.y);
      let width = maxX - minX;
      let height = maxY - minY;
      if (width < 1e-6) width = 1;
      if (height < 1e-6) height = 1;

      // genormeerde y posities, gesorteerd
      const yNormVals = [p0, p1, p2]
        .map(function (p) {
          return (p.y - minY) / height;
        })
        .sort(function (a, b) {
          return a - b;
        });

      // x patroon, gesorteerd op y van boven naar beneden
      const pointsWithIndex = [
        { p: p0, idx: 0 },
        { p: p1, idx: 1 },
        { p: p2, idx: 2 }
      ].sort(function (a, b) {
        return a.p.y - b.p.y;
      });

      const xPattern = pointsWithIndex.map(function (item) {
        return (item.p.x - minX) / width;
      });

      const aspect = height / (width + height);

      const centroidBox = {
        x: (centroidRaw.x - minX) / width,
        y: (centroidRaw.y - minY) / height
      };

      const vector = buildFeatureVector({
        sides: sidesNormSorted,
        orientation: orientation,
        cosAngle: cosAngle,
        centroid: centroidBox,
        yNorm: yNormVals,
        xPattern: xPattern,
        aspect: aspect
      });

      return {
        sides: sidesNormSorted,
        orientation: orientation,
        cosAngle: cosAngle,
        centroid: centroidBox,
        yNorm: yNormVals,
        xPattern: xPattern,
        aspect: aspect,
        vector: vector
      };
    }

    /**
     * Bouwt een gewogen featurevector op
     * door verschillende aspecten van het patroon te schalen.
     */
    function buildFeatureVector(f) {
      const wSides = 3.0;
      const wCos = 4.0;
      const wOrient = 2.0;
      const wY = 3.0;
      const wX = 2.0;
      const wAspect = 2.0;

      const v = [];
      v.push(f.sides[0] * wSides);
      v.push(f.sides[1] * wSides);
      v.push(f.sides[2] * wSides);

      v.push(f.cosAngle * wCos);
      v.push(f.orientation * wOrient);

      v.push(f.yNorm[0] * wY);
      v.push(f.yNorm[1] * wY);
      v.push(f.yNorm[2] * wY);

      v.push(f.xPattern[0] * wX);
      v.push(f.xPattern[1] * wX);
      v.push(f.xPattern[2] * wX);

      v.push(f.aspect * wAspect);

      return v;
    }

    /**
     * Euclidische afstand tussen twee featurevectoren.
     */
    function vectorDistance(a, b) {
      if (!a || !b || a.length !== b.length) return Infinity;
      let sum = 0;
      for (let i = 0; i < a.length; i++) {
        const diff = a[i] - b[i];
        sum += diff * diff;
      }
      return Math.sqrt(sum);
    }

    /**
     * Berekent drempels op basis van de kalibratiesamples.
     * thresholdBase: grens tussen zeker en twijfelachtig
     * thresholdUnknown: grens waarboven een meting als onbekend geldt
     */
    function recomputeClassificationStats() {
      if (!calibration) {
        classificationStats = {
          thresholdBase: 0.8,
          thresholdUnknown: 1.5
        };
        return;
      }

      const allSamples = [];
      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        if (!calibration[key]) return;
        const samples = calibration[key].samples || [];
        samples.forEach(function (s) {
          allSamples.push({ digit: d, features: s.features });
        });
      });

      if (allSamples.length < 2) {
        classificationStats = {
          thresholdBase: 0.6,
          thresholdUnknown: 1.0
        };
        return;
      }

      const sameMinDistances = [];
      const betweenMinDistances = [];

      for (let i = 0; i < allSamples.length; i++) {
        const a = allSamples[i];
        const vecA = a.features.vector;
        let minSame = Infinity;
        let minOther = Infinity;

        for (let j = 0; j < allSamples.length; j++) {
          if (i === j) continue;
          const b = allSamples[j];
          const vecB = b.features.vector;
          const dist = vectorDistance(vecA, vecB);

          if (a.digit === b.digit) {
            if (dist < minSame) minSame = dist;
          } else {
            if (dist < minOther) minOther = dist;
          }
        }

        if (minSame < Infinity) sameMinDistances.push(minSame);
        if (minOther < Infinity) betweenMinDistances.push(minOther);
      }

      if (sameMinDistances.length === 0 || betweenMinDistances.length === 0) {
        classificationStats = {
          thresholdBase: 0.7,
          thresholdUnknown: 1.2
        };
        return;
      }

      const maxSame = Math.max.apply(null, sameMinDistances);
      const minBetween = Math.min.apply(null, betweenMinDistances);

      let thresholdBase;
      if (minBetween > maxSame) {
        thresholdBase = (maxSame + minBetween) / 2;
      } else {
        thresholdBase = maxSame * 1.3;
      }
      const thresholdUnknown = thresholdBase * 1.5;

      classificationStats = {
        thresholdBase: thresholdBase,
        thresholdUnknown: thresholdUnknown,
        maxSame: maxSame,
        minBetween: minBetween
      };
    }

    /**
     * Classificeert een meting op basis van de featurevector
     * en de kalibratiegegevens.
     */
    function classifyMeasurement(features) {
      const vec = features.vector;
      if (!vec || !calibration) {
        return {
          digit: null,
          bestDist: null,
          certainty: "onbekend",
          isUnknown: true,
          topMatches: []
        };
      }

      const bestPerDigit = {};
      DIGIT_ORDER.forEach(function (d) {
        bestPerDigit[d] = Infinity;
      });

      let bestDigit = null;
      let bestDist = Infinity;

      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        const entry = calibration[key];
        if (!entry) return;
        const samples = entry.samples || [];
        for (let i = 0; i < samples.length; i++) {
          const sampleVec = samples[i].features.vector;
          const dist = vectorDistance(vec, sampleVec);
          if (dist < bestPerDigit[d]) {
            bestPerDigit[d] = dist;
          }
          if (dist < bestDist) {
            bestDist = dist;
            bestDigit = d;
          }
        }
      });

      const perDigitArray = [];
      DIGIT_ORDER.forEach(function (d) {
        const val = bestPerDigit[d];
        if (val < Infinity) {
          perDigitArray.push({ digit: d, distance: val });
        }
      });
      perDigitArray.sort(function (a, b) {
        return a.distance - b.distance;
      });
      const topMatches = perDigitArray.slice(0, 3);

      if (bestDigit === null || bestDist === Infinity) {
        return {
          digit: null,
          bestDist: null,
          certainty: "onbekend",
          isUnknown: true,
          topMatches: topMatches
        };
      }

      let stats = classificationStats;
      if (!stats) {
        stats = { thresholdBase: 0.8, thresholdUnknown: 1.5 };
      }

      const base = stats.thresholdBase;
      const unknownThresh = stats.thresholdUnknown;

      let isUnknown = false;
      let certainty = "zeker";

      if (bestDist > unknownThresh) {
        isUnknown = true;
      } else if (bestDist > base) {
        certainty = "twijfelachtig";
      }

      if (!isUnknown && topMatches.length > 1) {
        const second = topMatches[1].distance;
        if (second > 0) {
          const ratio = bestDist / second;
          if (ratio > 0.9 && certainty === "zeker") {
            certainty = "twijfelachtig";
          }
        }
      }

      return {
        digit: isUnknown ? null : bestDigit,
        bestDist: bestDist,
        certainty: certainty,
        isUnknown: isUnknown,
        topMatches: topMatches
      };
    }

    /**
     * Publieke functie voor de rest van je spel.
     *
     * Parameters:
     *   points: array met drie punten binnen de scanzone, elk {x, y}
     *
     * Retourneert:
     *   een cijfer 0 t/m 9 als er een betrouwbare herkenning is,
     *   of null als de meting onbekend is.
     */
    function recognizeDigit(points) {
      if (!calibration || !classificationStats) {
        return null;
      }

      if (!Array.isArray(points) || points.length !== expectedTouchPoints) {
        return null;
      }

      const features = computeFeatures(points);
      const classification = classifyMeasurement(features);

      if (!classification || classification.isUnknown || classification.digit == null) {
        return null;
      }

      return classification.digit;
    }

    /* ================================
       SPELLOGICA "WELK CIJFER MIST?"
       ================================ */

    document.addEventListener("DOMContentLoaded", function () {
      const numberRow = document.getElementById("number-row");
      const numberSlots = Array.from(
        document.querySelectorAll(".number-slot")
      );
      const feedbackEl = document.getElementById("feedback");
      const scanArea = document.getElementById("scan-area");

      let currentTriple = [1, 2, 3];
      let missingIndex = 1;
      let missingNumber = 2;
      let roundActive = true;

      let currentPoints = [];
      let hasResultForCurrentTouches = false;

      function setScanState(state) {
        scanArea.classList.remove(
          "state-neutral",
          "state-scanning",
          "state-correct",
          "state-wrong"
        );
        if (state === "scanning") {
          scanArea.classList.add("state-scanning");
        } else if (state === "correct") {
          scanArea.classList.add("state-correct");
        } else if (state === "wrong") {
          scanArea.classList.add("state-wrong");
        } else {
          scanArea.classList.add("state-neutral");
        }
      }

      function updateNumberDisplay() {
        numberSlots.forEach(function (slot, idx) {
          const span = slot.querySelector(".number-text");
          slot.classList.remove("missing", "correct-pop");
          if (idx === missingIndex) {
            slot.classList.add("missing");
            span.textContent = "?";
          } else {
            span.textContent = String(currentTriple[idx]);
          }
        });
      }

      function newRound() {
        roundActive = true;
        feedbackEl.textContent = "";
        setScanState("neutral");
        numberRow.classList.remove("shake");

        const base = 1 + Math.floor(Math.random() * 7); // 1..7 => (1,2,3) t/m (7,8,9)
        currentTriple = [base, base + 1, base + 2];
        missingIndex = Math.floor(Math.random() * 3); // 0,1,2
        missingNumber = currentTriple[missingIndex];
        updateNumberDisplay();
      }

      function handleRecognitionResult(digit) {
        if (!roundActive) return;

        if (digit === missingNumber) {
          // goed
          roundActive = false;
          setScanState("correct");
          feedbackEl.textContent = "üéâ";

          const missingSlot = numberSlots[missingIndex];
          const span = missingSlot.querySelector(".number-text");
          missingSlot.classList.remove("missing");
          missingSlot.classList.add("correct-pop");
          span.textContent = String(missingNumber);

          setTimeout(function () {
            newRound();
          }, 1200);
        } else {
          // fout
          setScanState("wrong");
          feedbackEl.textContent = "‚úñ";
          numberRow.classList.add("shake");
          setTimeout(function () {
            numberRow.classList.remove("shake");
            if (currentPoints.length === 0) {
              setScanState("neutral");
            } else {
              setScanState("scanning");
            }
          }, 450);
        }
      }

      function getPointsFromTouches(touchList) {
        const rect = scanArea.getBoundingClientRect();
        const points = [];

        for (let i = 0; i < touchList.length; i++) {
          const t = touchList[i];
          const x = t.clientX;
          const y = t.clientY;
          if (
            x >= rect.left &&
            x <= rect.right &&
            y >= rect.top &&
            y <= rect.bottom
          ) {
            points.push({ x: x, y: y });
          }
        }
        return points;
      }

      function handleTouchEvent(e) {
        // Multi-touch in scanzone
        const touches = e.touches || [];
        currentPoints = getPointsFromTouches(touches);

        if (currentPoints.length === 0) {
          hasResultForCurrentTouches = false;
          setScanState("neutral");
          return;
        }

        if (currentPoints.length !== expectedTouchPoints) {
          hasResultForCurrentTouches = false;
          setScanState("scanning");
          return;
        }

        setScanState("scanning");

        if (!hasResultForCurrentTouches && roundActive) {
          const digit = recognizeDigit(currentPoints);
          if (digit !== null && typeof digit === "number") {
            hasResultForCurrentTouches = true;
            handleRecognitionResult(digit);
          }
        }
      }

      function addTouchListeners(elem) {
        ["touchstart", "touchmove", "touchend", "touchcancel"].forEach(
          function (type) {
            elem.addEventListener(type, handleTouchEvent, { passive: true });
          }
        );
      }

      addTouchListeners(scanArea);
      newRound();

      // Kalibratie laden
      fetch("calibration.json")
        .then(function (r) {
          return r.json();
        })
        .then(function (data) {
          initCalibration(data);
        })
        .catch(function (err) {
          // Geen debug zichtbaar voor kinderen; alleen console.
          console.error("Kalibratie laden mislukt:", err);
        });
    });
  </script>
</body>
</html>
