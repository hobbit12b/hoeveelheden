<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Marbotic Cijfer Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #222;
      background-color: #f4f4f4;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
    }

    .app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header.top-bar {
      padding: 0.75rem 1rem;
      background: linear-gradient(135deg, #2196f3, #64b5f6);
      color: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }

    .top-bar-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .mode-indicator {
      font-size: 1.3rem;
      font-weight: 700;
    }

    .status {
      font-size: 0.95rem;
      opacity: 0.95;
    }

    main.content {
      flex: 1;
      display: flex;
      flex-direction: row;
      gap: 0.75rem;
      padding: 0.75rem;
    }

    .touch-area {
      flex: 3;
      min-height: 300px;
      background-color: #ffffff;
      border-radius: 1rem;
      box-shadow: 0 3px 8px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      position: relative;
      touch-action: none;
      overflow: hidden;
    }

    .instruction {
      font-size: 1.6rem;
      font-weight: 600;
      text-align: center;
      padding: 0.5rem 1rem;
    }

    .sub-instruction {
      margin-top: 0.5rem;
      font-size: 0.95rem;
      color: #555;
      text-align: center;
    }

    .scan-display {
      text-align: center;
    }

    .scan-label {
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      color: #555;
    }

    .predicted-digit {
      font-size: 6rem;
      font-weight: 800;
      color: #2196f3;
      text-shadow: 0 4px 8px rgba(0,0,0,0.15);
      line-height: 1;
    }

    .scan-result-label {
      margin-top: 0.3rem;
      font-size: 1.1rem;
      color: #555;
    }

    .scan-status {
      margin-top: 0.4rem;
      font-size: 0.95rem;
      color: #777;
    }

    .side-panel {
      flex: 2;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .buttons {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    button {
      font-size: 1rem;
      padding: 0.7rem 0.9rem;
      border-radius: 0.8rem;
      border: none;
      outline: none;
      background: #1976d2;
      color: white;
      font-weight: 600;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      width: 100%;
      cursor: pointer;
      touch-action: manipulation;
    }

    button:active {
      transform: scale(0.98);
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    button.secondary {
      background: #ffffff;
      color: #1976d2;
      border: 2px solid #1976d2;
      box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    }

    button.danger {
      background: #e53935;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }

    .debug-panel {
      background-color: #ffffff;
      border-radius: 0.9rem;
      padding: 0.6rem 0.8rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      font-size: 0.85rem;
    }

    .debug-panel h2 {
      margin: 0 0 0.4rem 0;
      font-size: 0.95rem;
      font-weight: 700;
      color: #333;
    }

    #debugCanvas {
      border: 1px solid #e0e0e0;
      border-radius: 0.5rem;
      width: 100%;
      max-width: 220px;
      display: block;
      margin-bottom: 0.4rem;
      background-color: #fafafa;
    }

    .debug-text {
      font-family: "SF Mono", Menlo, Consolas, monospace;
      white-space: pre-line;
      color: #444;
    }

    .data-section {
      padding: 0.6rem 0.75rem 0.9rem 0.75rem;
      border-top: 1px solid #ddd;
      background-color: #ffffff;
    }

    .data-section label {
      display: block;
      font-size: 0.9rem;
      margin-bottom: 0.3rem;
      color: #333;
    }

    #dataTextarea {
      width: 100%;
      min-height: 160px;
      font-family: "SF Mono", Menlo, Consolas, monospace;
      font-size: 0.85rem;
      padding: 0.4rem;
      border-radius: 0.5rem;
      border: 1px solid #ccc;
      resize: vertical;
    }

    footer {
      padding: 0.4rem 0.9rem 0.7rem 0.9rem;
      font-size: 0.8rem;
      color: #777;
    }

    .hidden {
      display: none !important;
    }

    @media (max-width: 900px) {
      main.content {
        flex-direction: column;
      }

      .side-panel {
        flex-direction: row;
        flex-wrap: wrap;
      }

      .buttons {
        flex: 2;
      }

      .debug-panel {
        flex: 1;
      }

      .predicted-digit {
        font-size: 4.5rem;
      }

      .instruction {
        font-size: 1.4rem;
      }
    }

    @media (max-width: 600px) {
      button {
        font-size: 0.95rem;
        padding: 0.6rem 0.8rem;
      }

      .top-bar-row {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
<div class="app">
  <header class="top-bar">
    <div class="top-bar-row">
      <div class="mode-indicator">
        Modus: <span id="modeLabel">Kalibreren</span>
      </div>
      <div class="status" id="statusLabel">
        Start met kalibreren en leg het cijfer 0 op het scherm.
      </div>
    </div>
  </header>

  <main class="content">
    <section id="touchArea" class="touch-area">
      <div id="calibrateInstruction" class="instruction">
        Leg nu het cijfer 0 op het scherm
      </div>
      <div id="calibrateSubInstruction" class="sub-instruction">
        Leg het cijfer zo recht mogelijk neer en raak het scherm alleen met het houten cijfer.
      </div>

      <div id="scanDisplay" class="scan-display hidden">
        <div class="scan-label">Herkenning</div>
        <div id="predictedDigit" class="predicted-digit">?</div>
        <div id="scanResultLabel" class="scan-result-label">Wachten op drie aanrakingen</div>
        <div id="scanStatusLabel" class="scan-status">Leg een gekalibreerd cijfer op het scherm.</div>
      </div>
    </section>

    <aside class="side-panel">
      <div class="buttons">
        <button id="toCalibrateBtn" class="secondary">Naar kalibreren</button>
        <button id="toScanBtn" disabled>Naar scannen</button>
        <button id="recalibrateBtn">Kalibreren opnieuw</button>
        <button id="resetBtn" class="danger">Wis kalibratie</button>
        <button id="showDataBtn" class="secondary">Toon kalibratiegegevens</button>
        <button id="copyDataBtn" class="secondary">Kopieer kalibratiegegevens</button>
      </div>

      <div class="debug-panel">
        <h2>Debug driehoek</h2>
        <canvas id="debugCanvas" width="160" height="160"></canvas>
        <div id="debugText" class="debug-text">
          Nog geen meting.
        </div>
      </div>
    </aside>
  </main>

  <section id="dataSection" class="data-section hidden">
    <label for="dataTextarea">Kalibratiegegevens (JSON) om te kopiëren</label>
    <textarea id="dataTextarea" readonly></textarea>
  </section>

  <footer>
    Tip: zet het scherm van de tablet of telefoon zo vlak mogelijk neer en zorg dat de houten cijfers schoon en droog zijn.
  </footer>
</div>

<script>
  (function () {
    "use strict";

    // Instelbare waarden voor gedrag
    const STABLE_TIME_MS = 200;              // Korter maakt de meting sneller
    const MOVE_TOLERANCE_PX = 25;
    const SAMPLES_PER_DIGIT = 6;             // Aantal metingen per cijfer tijdens kalibratie
    const MATCH_STRICT_THRESHOLD = 0.55;     // Onder deze waarde: zeker goed
    const MATCH_LOOSE_THRESHOLD = 0.8;       // Tussen strict en loose: twijfelachtig
    const MATCH_MARGIN = 0.08;               // Verschil tussen beste en tweede keus
    const ORIENTATION_PENALTY = 0.25;
    const FEATURE_WEIGHTS = {
      sides: 1,
      cos: 0.7,
      yNorm: 1.5
    };

    // Nieuwe sleutel zodat oude data geen problemen geeft
    const LOCAL_STORAGE_KEY = "marboticCalibrationMultiSampleV1";

    const DIGIT_ORDER = ["0","1","2","3","4","5","6","7","8","9"];
    const digitNames = {
      "0": "nul",
      "1": "een",
      "2": "twee",
      "3": "drie",
      "4": "vier",
      "5": "vijf",
      "6": "zes",
      "7": "zeven",
      "8": "acht",
      "9": "negen"
    };

    // UI elementen
    const modeLabel = document.getElementById("modeLabel");
    const statusLabel = document.getElementById("statusLabel");
    const touchArea = document.getElementById("touchArea");
    const calibrateInstruction = document.getElementById("calibrateInstruction");
    const calibrateSubInstruction = document.getElementById("calibrateSubInstruction");
    const scanDisplay = document.getElementById("scanDisplay");
    const predictedDigitEl = document.getElementById("predictedDigit");
    const scanResultLabel = document.getElementById("scanResultLabel");
    const scanStatusLabel = document.getElementById("scanStatusLabel");
    const toCalibrateBtn = document.getElementById("toCalibrateBtn");
    const toScanBtn = document.getElementById("toScanBtn");
    const recalibrateBtn = document.getElementById("recalibrateBtn");
    const resetBtn = document.getElementById("resetBtn");
    const showDataBtn = document.getElementById("showDataBtn");
    const copyDataBtn = document.getElementById("copyDataBtn");
    const dataSection = document.getElementById("dataSection");
    const dataTextarea = document.getElementById("dataTextarea");
    const debugCanvas = document.getElementById("debugCanvas");
    const debugText = document.getElementById("debugText");

    const ctx = debugCanvas.getContext("2d");

    // Interne staat
    let mode = "calibrate"; // "calibrate" of "scan"
    let calibration = {};
    let calibrationComplete = false;
    let currentDigitIndex = 0;
    let currentSampleIndex = 0;
    let waitingForRelease = false;
    let stableCandidate = null;
    let lastPrediction = null;

    // Kleine helpers voor meetkunde
    function distance(p, q) {
      const dx = p.x - q.x;
      const dy = p.y - q.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function clonePoints(points) {
      return points.map(p => ({ x: p.x, y: p.y, id: p.id }));
    }

    // Feature berekening per driehoek
    function computeFeatures(points) {
      if (!points || points.length !== 3) {
        return null;
      }

      const p0 = points[0];
      const p1 = points[1];
      const p2 = points[2];

      const d01 = distance(p0, p1);
      const d12 = distance(p1, p2);
      const d20 = distance(p2, p0);

      const sidesRaw = [d01, d12, d20];
      const maxSide = Math.max(d01, d12, d20) || 1;
      const sidesNorm = sidesRaw.map(v => v / maxSide);
      const sidesSorted = sidesNorm.slice().sort((a, b) => a - b);

      // Grootste hoek benaderen via cosinusregel
      let a = d01;
      let b = d12;
      let c = d20;
      let cosAngle = 0;
      const maxOriginal = Math.max(a, b, c);
      if (maxOriginal === a) {
        cosAngle = ((b * b + c * c - a * a) || 0) / (2 * b * c || 1);
      } else if (maxOriginal === b) {
        cosAngle = ((a * a + c * c - b * b) || 0) / (2 * a * c || 1);
      } else {
        cosAngle = ((a * a + b * b - c * c) || 0) / (2 * a * b || 1);
      }
      if (!Number.isFinite(cosAngle)) {
        cosAngle = 0;
      }

      // Orde van de punten (linksom of rechtsom)
      const cross =
        (p1.x - p0.x) * (p2.y - p0.y) -
        (p1.y - p0.y) * (p2.x - p0.x);
      const orientation = cross >= 0 ? 1 : -1;

      // Vertikale verdeling van de drie punten
      const ys = points.map(p => p.y);
      const minY = Math.min.apply(null, ys);
      const maxY = Math.max.apply(null, ys);
      let range = maxY - minY;
      if (range < 1) {
        range = 1;
      }
      const yNorm = points.map(p => (p.y - minY) / range);
      const ySorted = yNorm.slice().sort((a, b) => a - b);

      const centroid = {
        x: (p0.x + p1.x + p2.x) / 3,
        y: (p0.y + p1.y + p2.y) / 3
      };

      return {
        sides: sidesSorted,
        orientation: orientation,
        cosAngle: cosAngle,
        centroid: centroid,
        yNorm: ySorted
      };
    }

    function normalizeFeatures(raw) {
      if (!raw || typeof raw !== "object") {
        return null;
      }
      const sides = Array.isArray(raw.sides) ? raw.sides.slice(0, 3) : [0, 0, 0];
      while (sides.length < 3) sides.push(0);
      const sidesSorted = sides.slice().sort((a, b) => a - b);

      let yNorm = Array.isArray(raw.yNorm) ? raw.yNorm.slice(0, 3) : null;
      if (!yNorm) {
        yNorm = [0, 0.5, 1];
      }
      while (yNorm.length < 3) yNorm.push(0.5);
      const ySorted = yNorm.slice().sort((a, b) => a - b);

      const cosAngle = typeof raw.cosAngle === "number" ? raw.cosAngle : 0;
      const orientation = raw.orientation === 1 || raw.orientation === -1 ? raw.orientation : 0;

      return {
        sides: sidesSorted,
        yNorm: ySorted,
        cosAngle: cosAngle,
        orientation: orientation,
        centroid: raw.centroid || null
      };
    }

    // Afstand tussen twee feature sets
    function compareFeatures(f1, f2) {
      if (!f1 || !f2) {
        return Number.POSITIVE_INFINITY;
      }

      const s1 = f1.sides || [0, 0, 0];
      const s2 = f2.sides || [0, 0, 0];
      const y1 = f1.yNorm || [0, 0.5, 1];
      const y2 = f2.yNorm || [0, 0.5, 1];

      let dSidesSq = 0;
      let dYnormSq = 0;
      for (let i = 0; i < 3; i++) {
        const ds = (s1[i] || 0) - (s2[i] || 0);
        dSidesSq += ds * ds;
        const dy = (y1[i] || 0) - (y2[i] || 0);
        dYnormSq += dy * dy;
      }

      const dCos = (f1.cosAngle || 0) - (f2.cosAngle || 0);
      const dCosSq = dCos * dCos;

      let distSq =
        FEATURE_WEIGHTS.sides * dSidesSq +
        FEATURE_WEIGHTS.cos * dCosSq +
        FEATURE_WEIGHTS.yNorm * dYnormSq;

      let dist = Math.sqrt(distSq);

      const o1 = f1.orientation || 0;
      const o2 = f2.orientation || 0;
      if (o1 !== 0 && o2 !== 0 && o1 !== o2) {
        dist += ORIENTATION_PENALTY;
      }

      return dist;
    }

    // Beste match zoeken over alle cijfers en alle samples
    function findBestMatchMulti(features, calibrationData) {
      let bestDigit = null;
      let bestDist = Number.POSITIVE_INFINITY;
      let secondDigit = null;
      let secondDist = Number.POSITIVE_INFINITY;
      const perDigitDistances = {};

      DIGIT_ORDER.forEach(d => {
        const entry = calibrationData[d];
        if (!entry || !Array.isArray(entry.samples) || entry.samples.length === 0) {
          return;
        }
        let bestForDigit = Number.POSITIVE_INFINITY;
        entry.samples.forEach(sample => {
          if (!sample || !sample.features) return;
          const dist = compareFeatures(features, sample.features);
          if (dist < bestForDigit) {
            bestForDigit = dist;
          }
        });
        if (!Number.isFinite(bestForDigit)) {
          return;
        }
        perDigitDistances[d] = bestForDigit;

        if (bestForDigit < bestDist) {
          secondDist = bestDist;
          secondDigit = bestDigit;
          bestDist = bestForDigit;
          bestDigit = d;
        } else if (bestForDigit < secondDist) {
          secondDist = bestForDigit;
          secondDigit = d;
        }
      });

      return {
        digit: bestDigit,
        distance: bestDist,
        secondDigit: secondDigit,
        secondDistance: secondDist,
        perDigitDistances: perDigitDistances
      };
    }

    // Debug driehoek tekenen
    function drawTriangle(points) {
      ctx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
      if (!points || points.length !== 3) {
        return;
      }
      const xs = points.map(p => p.x);
      const ys = points.map(p => p.y);
      const minX = Math.min.apply(null, xs);
      const maxX = Math.max.apply(null, xs);
      const minY = Math.min.apply(null, ys);
      const maxY = Math.max.apply(null, ys);

      const width = maxX - minX || 1;
      const height = maxY - minY || 1;
      const padding = 10;
      const scale = Math.min(
        (debugCanvas.width - 2 * padding) / width,
        (debugCanvas.height - 2 * padding) / height
      );

      const cx = debugCanvas.width / 2;
      const cy = debugCanvas.height / 2;
      const midX = (minX + maxX) / 2;
      const midY = (minY + maxY) / 2;

      const mapped = points.map(p => {
        return {
          x: (p.x - midX) * scale + cx,
          y: (p.y - midY) * scale + cy
        };
      });

      ctx.beginPath();
      ctx.moveTo(mapped[0].x, mapped[0].y);
      ctx.lineTo(mapped[1].x, mapped[1].y);
      ctx.lineTo(mapped[2].x, mapped[2].y);
      ctx.closePath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#1976d2";
      ctx.stroke();

      ctx.fillStyle = "#ef6c00";
      mapped.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function updateDebugPanel(points, features, matchInfo) {
      drawTriangle(points);

      let text = "";
      if (features) {
        const s = features.sides || [0, 0, 0];
        const y = features.yNorm || [0, 0, 0];
        text += "Zijden (genormaliseerd):\n";
        text += "  " + s.map(v => v.toFixed(3)).join("  ") + "\n\n";
        text += "Verdeling hoog-laag:\n";
        text += "  " + y.map(v => v.toFixed(3)).join("  ") + "\n\n";
        text += "Oriëntatie: " + (features.orientation || 0) + "\n";
        text += "cos(hoek): " + (features.cosAngle || 0).toFixed(3) + "\n";
      } else {
        text += "Nog geen geldige driehoek.\n";
      }

      if (matchInfo && matchInfo.digit != null && Number.isFinite(matchInfo.distance)) {
        text += "\nBeste match: " + matchInfo.digit +
          "  (afstand " + matchInfo.distance.toFixed(3) + ")";
      } else if (mode === "scan") {
        text += "\nBeste match: geen";
      }

      debugText.textContent = text;
    }

    // Spraak
    function speakDigit(digitStr) {
      const name = digitNames[digitStr];
      if (!name) {
        return;
      }
      if (!("speechSynthesis" in window) || typeof window.SpeechSynthesisUtterance === "undefined") {
        return;
      }
      try {
        window.speechSynthesis.cancel();
        const utter = new window.SpeechSynthesisUtterance(name);
        utter.lang = "nl-NL";
        utter.rate = 1;
        window.speechSynthesis.speak(utter);
      } catch (e) {
        // Stil falen
      }
    }

    // Opslag
    function safeLoadCalibration() {
      try {
        const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (!stored) {
          return;
        }
        const parsed = JSON.parse(stored);
        if (!parsed || typeof parsed !== "object") {
          return;
        }

        const rebuilt = {};
        DIGIT_ORDER.forEach(d => {
          const entry = parsed[d];
          if (!entry) return;

          if (Array.isArray(entry.samples)) {
            const samples = [];
            entry.samples.forEach(s => {
              if (!s || !s.features || !s.points) return;
              const f = normalizeFeatures(s.features);
              if (!f) return;
              const pts = s.points.map(p => ({ x: p.x, y: p.y }));
              samples.push({ points: pts, features: f });
            });
            if (samples.length > 0) {
              rebuilt[d] = {
                digit: entry.digit != null ? entry.digit : parseInt(d, 10),
                samples: samples
              };
            }
          } else if (entry.features && entry.points) {
            const f = normalizeFeatures(entry.features);
            if (!f) return;
            const pts = entry.points.map(p => ({ x: p.x, y: p.y }));
            rebuilt[d] = {
              digit: entry.digit != null ? entry.digit : parseInt(d, 10),
              samples: [{ points: pts, features: f }]
            };
          }
        });

        calibration = rebuilt;
        calibrationComplete = checkCalibrationComplete();
        toScanBtn.disabled = !calibrationComplete;

        if (calibrationComplete) {
          statusLabel.textContent = "Kalibratie geladen uit opslag. Je kunt meteen scannen of opnieuw kalibreren.";
        }
      } catch (e) {
        // negeren
      }
    }

    function safeSaveCalibration() {
      try {
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(calibration));
      } catch (e) {
        // negeren
      }
    }

    function refreshDataTextarea() {
      dataTextarea.value = JSON.stringify(calibration, null, 2);
    }

    // UI modus wisselen
    function updateModeUI() {
      modeLabel.textContent = mode === "calibrate" ? "Kalibreren" : "Scannen";

      if (mode === "calibrate") {
        calibrateInstruction.classList.remove("hidden");
        calibrateSubInstruction.classList.remove("hidden");
        scanDisplay.classList.add("hidden");
        toCalibrateBtn.classList.add("secondary");
        toScanBtn.classList.remove("secondary");
      } else {
        calibrateInstruction.classList.add("hidden");
        calibrateSubInstruction.classList.add("hidden");
        scanDisplay.classList.remove("hidden");
        toCalibrateBtn.classList.remove("secondary");
        toScanBtn.classList.add("secondary");
      }
    }

    function setCalibrateInstruction() {
      const digitStr = DIGIT_ORDER[currentDigitIndex];
      const sampleNr = currentSampleIndex + 1;
      calibrateInstruction.textContent = "Leg nu het cijfer " + digitStr +
        " op het scherm (" + sampleNr + " van " + SAMPLES_PER_DIGIT + ")";

      if (sampleNr === 1) {
        calibrateSubInstruction.textContent =
          "Leg het cijfer zo recht mogelijk neer en raak het scherm alleen met het houten cijfer.";
      } else {
        calibrateSubInstruction.textContent =
          "Draai het cijfer een beetje en leg het opnieuw neer. Raak het scherm alleen met het houten cijfer.";
      }

      statusLabel.textContent =
        "Kalibreren: wacht op drie stabiele aanrakingen voor cijfer " +
        digitStr + " (meting " + sampleNr + " van " + SAMPLES_PER_DIGIT + ").";
    }

    function markSampleCaptured(digitStr) {
      const sampleNr = currentSampleIndex + 1;
      calibrateInstruction.textContent =
        "Cijfer " + digitStr + " vastgelegd, haal het cijfer van het scherm.";
      calibrateSubInstruction.textContent =
        "Wacht tot het scherm geen aanrakingen meer heeft. Leg daarna hetzelfde cijfer opnieuw neer, telkens iets anders gedraaid.";
      statusLabel.textContent =
        "Cijfer " + digitStr + " vastgelegd (" + sampleNr +
        " van " + SAMPLES_PER_DIGIT + "). Haal het cijfer van het scherm.";
    }

    function checkCalibrationComplete() {
      return DIGIT_ORDER.every(d =>
        calibration[d] &&
        Array.isArray(calibration[d].samples) &&
        calibration[d].samples.length > 0
      );
    }

    function advanceAfterRelease() {
      if (currentSampleIndex + 1 < SAMPLES_PER_DIGIT) {
        currentSampleIndex += 1;
        setCalibrateInstruction();
      } else if (currentDigitIndex + 1 < DIGIT_ORDER.length) {
        currentDigitIndex += 1;
        currentSampleIndex = 0;
        setCalibrateInstruction();
      } else {
        calibrationComplete = true;
        toScanBtn.disabled = false;
        calibrateInstruction.textContent = "Kalibratie compleet.";
        calibrateSubInstruction.textContent =
          "Je kunt nu naar scannen gaan of later opnieuw kalibreren.";
        statusLabel.textContent = "Kalibratie voltooid voor alle cijfers.";
        safeSaveCalibration();
        refreshDataTextarea();
      }
    }

    function resetCalibrationState(clearStorage) {
      calibration = {};
      calibrationComplete = false;
      currentDigitIndex = 0;
      currentSampleIndex = 0;
      waitingForRelease = false;
      stableCandidate = null;
      lastPrediction = null;
      toScanBtn.disabled = true;
      predictedDigitEl.textContent = "?";
      scanResultLabel.textContent = "Wachten op drie aanrakingen";
      scanStatusLabel.textContent = "Leg een gekalibreerd cijfer op het scherm.";
      updateDebugPanel(null, null, null);
      setCalibrateInstruction();
      if (clearStorage) {
        try {
          localStorage.removeItem(LOCAL_STORAGE_KEY);
        } catch (e) {}
        refreshDataTextarea();
      }
    }

    // Resultaat tonen in scanmodus
    function setPredictionResult(result) {
      if (!result || !result.digit || !Number.isFinite(result.distance)) {
        predictedDigitEl.textContent = "?";
        scanResultLabel.textContent = "Onbekend";
        scanStatusLabel.textContent = "Meting twijfelachtig of vorm wijkt af.";
        lastPrediction = null;
        return;
      }

      const digitStr = result.digit;
      const dist = result.distance;
      const secondDist = result.secondDistance != null ? result.secondDistance : Number.POSITIVE_INFINITY;

      let quality = "unknown";

      if (dist < MATCH_STRICT_THRESHOLD && (secondDist - dist) > MATCH_MARGIN) {
        quality = "sure";
      } else if (dist < MATCH_LOOSE_THRESHOLD && (secondDist - dist) > MATCH_MARGIN / 2) {
        quality = "maybe";
      } else {
        quality = "unknown";
      }

      if (quality === "unknown") {
        predictedDigitEl.textContent = "?";
        scanResultLabel.textContent = "Onbekend";
        scanStatusLabel.textContent =
          "Meting twijfelachtig of vorm wijkt te veel af van de kalibratie.";
        lastPrediction = null;
        return;
      }

      predictedDigitEl.textContent = digitStr;
      if (quality === "sure") {
        scanResultLabel.textContent = "Herkenning: " + digitStr;
        scanStatusLabel.textContent = "Zeker (afstand " + dist.toFixed(3) + ").";
        if (lastPrediction !== digitStr) {
          lastPrediction = digitStr;
          speakDigit(digitStr);
        }
      } else {
        scanResultLabel.textContent = "Waarschijnlijk: " + digitStr;
        scanStatusLabel.textContent =
          "Meting twijfelachtig (afstand " + dist.toFixed(3) + ").";
        lastPrediction = digitStr;
      }
    }

    function clearPrediction() {
      predictedDigitEl.textContent = "?";
      scanResultLabel.textContent = "Wachten op drie aanrakingen";
      scanStatusLabel.textContent = "Leg een gekalibreerd cijfer op het scherm.";
      lastPrediction = null;
    }

    // Touch helpers
    function touchesToPoints(touchList) {
      const arr = [];
      for (let i = 0; i < touchList.length; i++) {
        const t = touchList.item(i);
        arr.push({
          id: t.identifier,
          x: t.clientX,
          y: t.clientY
        });
      }
      return arr;
    }

    function idsFromPoints(points) {
      return points.map(p => p.id).sort();
    }

    function sameIds(pointsA, pointsB) {
      if (!pointsA || !pointsB || pointsA.length !== pointsB.length) {
        return false;
      }
      const idsA = idsFromPoints(pointsA);
      const idsB = idsFromPoints(pointsB);
      for (let i = 0; i < idsA.length; i++) {
        if (idsA[i] !== idsB[i]) {
          return false;
        }
      }
      return true;
    }

    function maxMovement(pointsNow, pointsOrigin) {
      if (!pointsNow || !pointsOrigin || pointsNow.length !== pointsOrigin.length) {
        return Number.POSITIVE_INFINITY;
      }
      let maxMove = 0;
      for (let i = 0; i < pointsNow.length; i++) {
        const pNow = pointsNow[i];
        let origin = pointsOrigin.find(p => p.id === pNow.id);
        if (!origin) {
          origin = pointsOrigin[i];
        }
        const d = distance(pNow, origin);
        if (d > maxMove) {
          maxMove = d;
        }
      }
      return maxMove;
    }

    function ensureDigitEntry(digitStr) {
      if (!calibration[digitStr]) {
        calibration[digitStr] = {
          digit: parseInt(digitStr, 10),
          samples: []
        };
      }
    }

    // Als drie punten lang genoeg stabiel zijn
    function handleStableThreePoints(points) {
      const purePoints = points.map(p => ({ x: p.x, y: p.y }));
      const features = computeFeatures(purePoints);
      if (!features) {
        return;
      }

      if (mode === "calibrate") {
        if (calibrationComplete) {
          return;
        }
        const digitStr = DIGIT_ORDER[currentDigitIndex];
        ensureDigitEntry(digitStr);
        calibration[digitStr].samples.push({
          points: purePoints,
          features: features
        });
        markSampleCaptured(digitStr);
        waitingForRelease = true;
        updateDebugPanel(purePoints, features, null);
        safeSaveCalibration();
        refreshDataTextarea();
      } else if (mode === "scan") {
        if (!calibrationComplete) {
          statusLabel.textContent =
            "Scannen is niet beschikbaar. Kalibreer eerst alle cijfers.";
          clearPrediction();
          return;
        }
        const match = findBestMatchMulti(features, calibration);
        setPredictionResult(match);
        updateDebugPanel(purePoints, features, match);
      }
    }

    function processTouches(touches) {
      const now = performance.now();
      const count = touches.length;

      if (mode === "calibrate") {
        if (waitingForRelease) {
          if (count === 0) {
            waitingForRelease = false;
            if (!calibrationComplete) {
              advanceAfterRelease();
            }
          }
          return;
        }
        if (calibrationComplete) {
          return;
        }
      } else if (mode === "scan") {
        if (!calibrationComplete) {
          clearPrediction();
        }
      }

      if (count !== 3) {
        stableCandidate = null;
        if (mode === "scan" && count === 0) {
          clearPrediction();
        }
        return;
      }

      if (!stableCandidate || !sameIds(touches, stableCandidate.originPoints)) {
        stableCandidate = {
          originPoints: clonePoints(touches),
          startTime: now,
          lastPoints: clonePoints(touches),
          triggered: false
        };
        if (mode === "scan") {
          scanStatusLabel.textContent = "Metingen worden gestabiliseerd.";
        } else {
          statusLabel.textContent =
            "Metingen worden gestabiliseerd voor dit cijfer.";
        }
        return;
      }

      const move = maxMovement(touches, stableCandidate.originPoints);
      if (move > MOVE_TOLERANCE_PX) {
        stableCandidate = {
          originPoints: clonePoints(touches),
          startTime: now,
          lastPoints: clonePoints(touches),
          triggered: false
        };
        return;
      }

      if (!stableCandidate.triggered && now - stableCandidate.startTime >= STABLE_TIME_MS) {
        stableCandidate.triggered = true;
        handleStableThreePoints(touches);
      }
    }

    function onTouchChange(evt) {
      if (evt.touches && evt.touches.length > 0) {
        evt.preventDefault();
      }
      const touches = touchesToPoints(evt.touches);
      processTouches(touches);
    }

    function onTouchEndOrCancel(evt) {
      if (evt.touches && evt.touches.length > 0) {
        evt.preventDefault();
      }
      const touches = touchesToPoints(evt.touches);
      processTouches(touches);
    }

    // Knoppen
    toCalibrateBtn.addEventListener("click", function () {
      mode = "calibrate";
      updateModeUI();
      if (!calibrationComplete) {
        setCalibrateInstruction();
      } else {
        statusLabel.textContent =
          "Je zit in kalibreer modus. Je kunt opnieuw kalibreren of naar scannen gaan.";
      }
    });

    toScanBtn.addEventListener("click", function () {
      if (!calibrationComplete) {
        statusLabel.textContent =
          "Scannen is niet beschikbaar. Kalibreer eerst alle cijfers.";
        return;
      }
      mode = "scan";
      updateModeUI();
      clearPrediction();
      statusLabel.textContent =
        "Scan modus. Leg een gekalibreerd cijfer met drie contactpunten op het scherm.";
    });

    recalibrateBtn.addEventListener("click", function () {
      resetCalibrationState(false);
      statusLabel.textContent =
        "Kalibratie opnieuw gestart. Leg het cijfer 0 op het scherm.";
      if (mode !== "calibrate") {
        mode = "calibrate";
        updateModeUI();
      }
    });

    resetBtn.addEventListener("click", function () {
      resetCalibrationState(true);
      statusLabel.textContent =
        "Kalibratie gewist. Start opnieuw bij cijfer 0.";
      if (mode !== "calibrate") {
        mode = "calibrate";
        updateModeUI();
      }
    });

    showDataBtn.addEventListener("click", function () {
      const willShow = dataSection.classList.contains("hidden");
      if (willShow) {
        refreshDataTextarea();
        dataSection.classList.remove("hidden");
        showDataBtn.textContent = "Verberg kalibratiegegevens";
      } else {
        dataSection.classList.add("hidden");
        showDataBtn.textContent = "Toon kalibratiegegevens";
      }
    });

    function fallbackCopyData() {
      // Toon tekstveld zodat selecteren zichtbaar is
      dataSection.classList.remove("hidden");
      refreshDataTextarea();
      dataTextarea.focus();
      dataTextarea.select();
      let ok = false;
      try {
        if (document.execCommand) {
          ok = document.execCommand("copy");
        }
      } catch (e) {
        ok = false;
      }
      if (ok) {
        statusLabel.textContent = "Kalibratiegegevens gekopieerd.";
      } else {
        statusLabel.textContent =
          "Kopiëren is niet gelukt, selecteer en kopieer zelf de tekst.";
      }
    }

    copyDataBtn.addEventListener("click", function () {
      refreshDataTextarea();
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(dataTextarea.value)
          .then(function () {
            statusLabel.textContent = "Kalibratiegegevens gekopieerd.";
          })
          .catch(function () {
            fallbackCopyData();
          });
      } else {
        fallbackCopyData();
      }
    });

    touchArea.addEventListener("touchstart", onTouchChange, { passive: false });
    touchArea.addEventListener("touchmove", onTouchChange, { passive: false });
    touchArea.addEventListener("touchend", onTouchEndOrCancel, { passive: false });
    touchArea.addEventListener("touchcancel", onTouchEndOrCancel, { passive: false });

    // Start
    resetCalibrationState(false);
    safeLoadCalibration();
    updateModeUI();
    if (calibrationComplete) {
      refreshDataTextarea();
    }
  })();
</script>
</body>
</html>
