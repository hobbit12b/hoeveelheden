<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Marbotic Cijfer Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #222;
      background-color: #f4f4f4;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
    }

    .app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header.top-bar {
      padding: 0.75rem 1rem;
      background: linear-gradient(135deg, #2196f3, #64b5f6);
      color: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }

    .top-bar-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .mode-indicator {
      font-size: 1.3rem;
      font-weight: 700;
    }

    .status {
      font-size: 0.95rem;
      opacity: 0.95;
    }

    main.content {
      flex: 1;
      display: flex;
      flex-direction: row;
      gap: 0.75rem;
      padding: 0.75rem;
    }

    .touch-area {
      flex: 3;
      min-height: 300px;
      background-color: #ffffff;
      border-radius: 1rem;
      box-shadow: 0 3px 8px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      position: relative;
      touch-action: none;
      overflow: hidden;
    }

    .instruction {
      font-size: 1.6rem;
      font-weight: 600;
      text-align: center;
      padding: 0.5rem 1rem;
    }

    .sub-instruction {
      margin-top: 0.5rem;
      font-size: 0.95rem;
      color: #555;
      text-align: center;
    }

    .scan-display {
      text-align: center;
    }

    .scan-label {
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      color: #555;
    }

    .predicted-digit {
      font-size: 6rem;
      font-weight: 800;
      color: #2196f3;
      text-shadow: 0 4px 8px rgba(0,0,0,0.15);
      line-height: 1;
    }

    .scan-result-label {
      margin-top: 0.3rem;
      font-size: 1.1rem;
      color: #555;
    }

    .scan-status {
      margin-top: 0.4rem;
      font-size: 0.95rem;
      color: #777;
    }

    .side-panel {
      flex: 2;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .buttons {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    button {
      font-size: 1rem;
      padding: 0.7rem 0.9rem;
      border-radius: 0.8rem;
      border: none;
      outline: none;
      background: #1976d2;
      color: white;
      font-weight: 600;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      width: 100%;
      cursor: pointer;
      touch-action: manipulation;
    }

    button:active {
      transform: scale(0.98);
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    button.secondary {
      background: #ffffff;
      color: #1976d2;
      border: 2px solid #1976d2;
      box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    }

    button.danger {
      background: #e53935;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }

    .debug-panel {
      background-color: #ffffff;
      border-radius: 0.9rem;
      padding: 0.6rem 0.8rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      font-size: 0.85rem;
    }

    .debug-panel h2 {
      margin: 0 0 0.4rem 0;
      font-size: 0.95rem;
      font-weight: 700;
      color: #333;
    }

    #debugCanvas {
      border: 1px solid #e0e0e0;
      border-radius: 0.5rem;
      width: 100%;
      max-width: 220px;
      display: block;
      margin-bottom: 0.4rem;
      background-color: #fafafa;
    }

    .debug-text {
      font-family: "SF Mono", Menlo, Consolas, monospace;
      white-space: pre-line;
      color: #444;
    }

    .data-section {
      padding: 0.6rem 0.75rem 0.9rem 0.75rem;
      border-top: 1px solid #ddd;
      background-color: #ffffff;
    }

    .data-section label {
      display: block;
      font-size: 0.9rem;
      margin-bottom: 0.3rem;
      color: #333;
    }

    #dataTextarea {
      width: 100%;
      min-height: 160px;
      font-family: "SF Mono", Menlo, Consolas, monospace;
      font-size: 0.85rem;
      padding: 0.4rem;
      border-radius: 0.5rem;
      border: 1px solid #ccc;
      resize: vertical;
    }

    footer {
      padding: 0.4rem 0.9rem 0.7rem 0.9rem;
      font-size: 0.8rem;
      color: #777;
    }

    .hidden {
      display: none !important;
    }

    @media (max-width: 900px) {
      main.content {
        flex-direction: column;
      }

      .side-panel {
        flex-direction: row;
        flex-wrap: wrap;
      }

      .buttons {
        flex: 2;
      }

      .debug-panel {
        flex: 1;
      }

      .predicted-digit {
        font-size: 4.5rem;
      }

      .instruction {
        font-size: 1.4rem;
      }
    }

    @media (max-width: 600px) {
      button {
        font-size: 0.95rem;
        padding: 0.6rem 0.8rem;
      }

      .top-bar-row {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
<div class="app">
  <header class="top-bar">
    <div class="top-bar-row">
      <div class="mode-indicator">
        Modus: <span id="modeLabel">Kalibreren</span>
      </div>
      <div class="status" id="statusLabel">
        Start met kalibreren en leg het cijfer 0 op het scherm.
      </div>
    </div>
  </header>

  <main class="content">
    <section id="touchArea" class="touch-area">
      <div id="calibrateInstruction" class="instruction">
        Leg nu het cijfer 0 op het scherm
      </div>
      <div id="calibrateSubInstruction" class="sub-instruction">
        Raak het scherm alleen met het houten cijfer, geen vingers. De app legt het cijfer automatisch vast.
      </div>

      <div id="scanDisplay" class="scan-display hidden">
        <div class="scan-label">Herkenning</div>
        <div id="predictedDigit" class="predicted-digit">?</div>
        <div id="scanResultLabel" class="scan-result-label">Wachten op drie aanrakingen</div>
        <div id="scanStatusLabel" class="scan-status">Leg een gekalibreerd cijfer op het scherm.</div>
      </div>
    </section>

    <aside class="side-panel">
      <div class="buttons">
        <button id="toCalibrateBtn" class="secondary">Naar kalibreren</button>
        <button id="toScanBtn" disabled>Naar scannen</button>
        <button id="recalibrateBtn">Kalibreren opnieuw</button>
        <button id="resetBtn" class="danger">Wis kalibratie</button>
        <button id="showDataBtn" class="secondary">Toon kalibratiegegevens</button>
        <button id="copyDataBtn" class="secondary">Kopieer kalibratiegegevens</button>
      </div>

      <div class="debug-panel">
        <h2>Debug driehoek</h2>
        <canvas id="debugCanvas" width="160" height="160"></canvas>
        <div id="debugText" class="debug-text">
          Nog geen meting.
        </div>
      </div>
    </aside>
  </main>

  <section id="dataSection" class="data-section hidden">
    <label for="dataTextarea">Kalibratiegegevens (JSON)</label>
    <textarea id="dataTextarea" readonly></textarea>
  </section>

  <footer>
    Tip: zet het scherm van de tablet of telefoon zo vlak mogelijk neer en zorg dat de houten cijfers schoon en droog zijn.
  </footer>
</div>

<script>
  (function () {
    "use strict";

    // Instellingen voor stabiliteit en herkenning
    const STABLE_TIME_MS = 220;           // hoe lang drie punten bijna stil moeten liggen
    const MOVE_TOLERANCE_PX = 35;         // hoeveel ze mogen schuiven tijdens stabiliseren
    const LOCAL_STORAGE_KEY = "marboticCalibrationV2";
    const SAMPLES_PER_DIGIT = 6;          // aantal metingen per cijfer bij kalibreren
    let MATCH_THRESHOLD = 0.55;           // drempel voor acceptatie van een match
    const AMBIGUITY_MARGIN = 0.07;        // minimaal verschil tussen beste en tweede match

    // Wegingen voor de vormvergelijking
    const SIDE_WEIGHT = 1.0;
    const COS_WEIGHT = 0.9;
    const Y_WEIGHT = 0.7;
    const ORIENTATION_PENALTY = 0.25;

    const DIGIT_ORDER = ["0","1","2","3","4","5","6","7","8","9"];
    const digitNames = {
      "0": "nul",
      "1": "een",
      "2": "twee",
      "3": "drie",
      "4": "vier",
      "5": "vijf",
      "6": "zes",
      "7": "zeven",
      "8": "acht",
      "9": "negen"
    };

    // UI elementen
    const modeLabel = document.getElementById("modeLabel");
    const statusLabel = document.getElementById("statusLabel");
    const touchArea = document.getElementById("touchArea");
    const calibrateInstruction = document.getElementById("calibrateInstruction");
    const calibrateSubInstruction = document.getElementById("calibrateSubInstruction");
    const scanDisplay = document.getElementById("scanDisplay");
    const predictedDigitEl = document.getElementById("predictedDigit");
    const scanResultLabel = document.getElementById("scanResultLabel");
    const scanStatusLabel = document.getElementById("scanStatusLabel");
    const toCalibrateBtn = document.getElementById("toCalibrateBtn");
    const toScanBtn = document.getElementById("toScanBtn");
    const recalibrateBtn = document.getElementById("recalibrateBtn");
    const resetBtn = document.getElementById("resetBtn");
    const showDataBtn = document.getElementById("showDataBtn");
    const copyDataBtn = document.getElementById("copyDataBtn");
    const dataSection = document.getElementById("dataSection");
    const dataTextarea = document.getElementById("dataTextarea");
    const debugCanvas = document.getElementById("debugCanvas");
    const debugText = document.getElementById("debugText");

    const ctx = debugCanvas.getContext("2d");

    // Toestand
    let mode = "calibrate";       // "calibrate" of "scan"
    let calibration = {};         // per cijfer: { digit, samples: [ { points, features } ] }
    let calibrationComplete = false;
    let currentDigitIndex = 0;
    let waitingForRelease = false;
    let stableCandidate = null;
    let lastPrediction = null;

    function distance(p, q) {
      const dx = p.x - q.x;
      const dy = p.y - q.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function clonePoints(points) {
      return points.map(p => ({ x: p.x, y: p.y, id: p.id }));
    }

    function computeFeatures(points) {
      if (!points || points.length !== 3) {
        return null;
      }
      const p0 = points[0];
      const p1 = points[1];
      const p2 = points[2];

      const centroid = {
        x: (p0.x + p1.x + p2.x) / 3,
        y: (p0.y + p1.y + p2.y) / 3
      };

      const d01 = distance(p0, p1);
      const d12 = distance(p1, p2);
      const d20 = distance(p2, p0);

      const sidesRaw = [d01, d12, d20];
      const maxSide = Math.max(d01, d12, d20) || 1;
      const sidesNorm = sidesRaw.map(v => v / maxSide);
      const sidesSorted = sidesNorm.slice().sort((a, b) => a - b);

      let a = d01;
      let b = d12;
      let c = d20;
      let cosAngle = 0;
      const maxOriginal = Math.max(a, b, c);
      if (maxOriginal === a) {
        cosAngle = ((b * b + c * c - a * a) || 0) / (2 * b * c || 1);
      } else if (maxOriginal === b) {
        cosAngle = ((a * a + c * c - b * b) || 0) / (2 * a * c || 1);
      } else {
        cosAngle = ((a * a + b * b - c * c) || 0) / (2 * a * b || 1);
      }
      if (!Number.isFinite(cosAngle)) {
        cosAngle = 0;
      }

      const cross =
        (p1.x - p0.x) * (p2.y - p0.y) -
        (p1.y - p0.y) * (p2.x - p0.x);
      const orientation = cross >= 0 ? 1 : -1;

      const ys = [p0.y, p1.y, p2.y];
      const minY = Math.min(ys[0], ys[1], ys[2]);
      const maxY = Math.max(ys[0], ys[1], ys[2]);
      const range = maxY - minY || 1;
      const yNorm = ys.map(y => (y - minY) / range).sort((a, b) => a - b);

      return {
        sides: sidesSorted,
        orientation: orientation,
        cosAngle: cosAngle,
        centroid: centroid,
        yNorm: yNorm
      };
    }

    function compareFeatures(f1, f2) {
      if (!f1 || !f2) {
        return Number.POSITIVE_INFINITY;
      }
      const s1 = f1.sides || [0, 0, 0];
      const s2 = f2.sides || [0, 0, 0];
      const y1 = f1.yNorm || [0, 0, 0];
      const y2 = f2.yNorm || [0, 0, 0];

      const d0 = s1[0] - s2[0];
      const d1 = s1[1] - s2[1];
      const d2 = s1[2] - s2[2];
      const dy0 = y1[0] - y2[0];
      const dy1 = y1[1] - y2[1];
      const dy2 = y1[2] - y2[2];
      const dCos = (f1.cosAngle || 0) - (f2.cosAngle || 0);

      let distSq = 0;
      distSq += SIDE_WEIGHT * (d0 * d0 + d1 * d1 + d2 * d2);
      distSq += COS_WEIGHT * dCos * dCos;
      distSq += Y_WEIGHT * (dy0 * dy0 + dy1 * dy1 + dy2 * dy2);

      let dist = Math.sqrt(distSq);
      if ((f1.orientation || 0) !== (f2.orientation || 0)) {
        dist += ORIENTATION_PENALTY;
      }
      return dist;
    }

    function findBestMatch(features, calibrationData) {
      let bestDigit = null;
      let bestDist = Number.POSITIVE_INFINITY;
      let secondBestDist = Number.POSITIVE_INFINITY;

      DIGIT_ORDER.forEach(d => {
        const entry = calibrationData[d];
        if (!entry || !entry.samples || !entry.samples.length) {
          return;
        }
        entry.samples.forEach(sample => {
          if (!sample.features) {
            return;
          }
          const dist = compareFeatures(features, sample.features);
          if (dist < bestDist) {
            secondBestDist = bestDist;
            bestDist = dist;
            bestDigit = d;
          } else if (dist < secondBestDist) {
            secondBestDist = dist;
          }
        });
      });

      return {
        digit: bestDigit,
        distance: bestDist,
        secondBest: secondBestDist
      };
    }

    function drawTriangle(points) {
      ctx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
      if (!points || points.length !== 3) {
        return;
      }
      const xs = points.map(p => p.x);
      const ys = points.map(p => p.y);
      const minX = Math.min.apply(null, xs);
      const maxX = Math.max.apply(null, xs);
      const minY = Math.min.apply(null, ys);
      const maxY = Math.max.apply(null, ys);

      const width = maxX - minX || 1;
      const height = maxY - minY || 1;
      const padding = 10;
      const scale = Math.min(
        (debugCanvas.width - 2 * padding) / width,
        (debugCanvas.height - 2 * padding) / height
      );

      const cx = debugCanvas.width / 2;
      const cy = debugCanvas.height / 2;
      const midX = (minX + maxX) / 2;
      const midY = (minY + maxY) / 2;

      const mapped = points.map(p => {
        return {
          x: (p.x - midX) * scale + cx,
          y: (p.y - midY) * scale + cy
        };
      });

      ctx.beginPath();
      ctx.moveTo(mapped[0].x, mapped[0].y);
      ctx.lineTo(mapped[1].x, mapped[1].y);
      ctx.lineTo(mapped[2].x, mapped[2].y);
      ctx.closePath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#1976d2";
      ctx.stroke();

      ctx.fillStyle = "#ef6c00";
      mapped.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function updateDebugPanel(points, features, matchInfo) {
      drawTriangle(points);

      let text = "";
      if (features) {
        const s = features.sides || [0, 0, 0];
        text += "Zijden (genormaliseerd):\n";
        text += "  " + s.map(v => v.toFixed(3)).join("  ") + "\n\n";
        text += "Oriëntatie: " + (features.orientation || 0) + "\n";
        text += "cos(hoek): " + (features.cosAngle || 0).toFixed(3) + "\n";
        if (features.yNorm) {
          text += "yNorm: " + features.yNorm.map(v => v.toFixed(3)).join("  ") + "\n";
        }
      } else {
        text += "Nog geen geldige driehoek.\n";
      }

      if (matchInfo && matchInfo.digit != null && Number.isFinite(matchInfo.distance)) {
        text += "\nBeste match: " + matchInfo.digit +
          "  (afstand " + matchInfo.distance.toFixed(3) + ")";
        if (Number.isFinite(matchInfo.secondBest)) {
          const margin = matchInfo.secondBest - matchInfo.distance;
          text += "\nVerschil met tweede: " + margin.toFixed(3);
        }
      } else if (mode === "scan") {
        text += "\nBeste match: geen";
      }

      debugText.textContent = text;
    }

    function speakDigit(digitStr) {
      const name = digitNames[digitStr];
      if (!name) {
        return;
      }
      if (!("speechSynthesis" in window) || typeof window.SpeechSynthesisUtterance === "undefined") {
        return;
      }
      try {
        window.speechSynthesis.cancel();
        const utter = new window.SpeechSynthesisUtterance(name);
        utter.lang = "nl-NL";
        utter.rate = 1;
        window.speechSynthesis.speak(utter);
      } catch (e) {
        // stil falen
      }
    }

    function refreshDataTextarea() {
      dataTextarea.value = JSON.stringify(calibration, null, 2);
    }

    function recomputeAdaptiveThreshold() {
      let maxSame = 0;

      DIGIT_ORDER.forEach(d => {
        const entry = calibration[d];
        if (!entry || !entry.samples || entry.samples.length < 2) {
          return;
        }
        const feats = entry.samples
          .map(s => s.features)
          .filter(f => !!f);
        for (let i = 0; i < feats.length; i++) {
          for (let j = i + 1; j < feats.length; j++) {
            const dist = compareFeatures(feats[i], feats[j]);
            if (Number.isFinite(dist) && dist > maxSame) {
              maxSame = dist;
            }
          }
        }
      });

      if (maxSame > 0 && Number.isFinite(maxSame)) {
        MATCH_THRESHOLD = Math.max(0.3, maxSame * 1.6);
      }
    }

    function safeLoadCalibration() {
      try {
        const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (!stored) {
          return;
        }
        const parsed = JSON.parse(stored);
        if (!parsed || typeof parsed !== "object") {
          return;
        }

        let isV2 = true;
        DIGIT_ORDER.forEach(d => {
          if (!parsed[d] || !Array.isArray(parsed[d].samples) || !parsed[d].samples.length) {
            isV2 = false;
          }
        });

        let isV1 = true;
        DIGIT_ORDER.forEach(d => {
          if (!parsed[d] || !parsed[d].features || !parsed[d].points) {
            isV1 = false;
          }
        });

        if (isV2) {
          calibration = parsed;
          calibrationComplete = true;
          toScanBtn.disabled = false;
          recomputeAdaptiveThreshold();
          statusLabel.textContent = "Kalibratie geladen uit opslag. Je kunt naar scannen gaan of opnieuw kalibreren.";
          return;
        }

        if (isV1) {
          const upgraded = {};
          DIGIT_ORDER.forEach(d => {
            const entry = parsed[d];
            const purePoints = (entry.points || []).map(p => ({ x: p.x, y: p.y }));
            const feats = computeFeatures(purePoints);
            upgraded[d] = {
              digit: entry.digit != null ? entry.digit : parseInt(d, 10),
              samples: [
                {
                  points: purePoints,
                  features: feats
                }
              ]
            };
          });
          calibration = upgraded;
          calibrationComplete = true;
          toScanBtn.disabled = false;
          recomputeAdaptiveThreshold();
          safeSaveCalibration();
          statusLabel.textContent = "Oude kalibratie is omgezet en geladen. Je kunt naar scannen gaan of opnieuw kalibreren.";
        }
      } catch (e) {
        // bij fout gewoon niets laden
      }
    }

    function safeSaveCalibration() {
      try {
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(calibration));
      } catch (e) {
        // geen harde fout
      }
    }

    function updateModeUI() {
      modeLabel.textContent = mode === "calibrate" ? "Kalibreren" : "Scannen";

      if (mode === "calibrate") {
        calibrateInstruction.classList.remove("hidden");
        calibrateSubInstruction.classList.remove("hidden");
        scanDisplay.classList.add("hidden");
        toCalibrateBtn.classList.add("secondary");
        toScanBtn.classList.remove("secondary");
      } else {
        calibrateInstruction.classList.add("hidden");
        calibrateSubInstruction.classList.add("hidden");
        scanDisplay.classList.remove("hidden");
        toCalibrateBtn.classList.remove("secondary");
        toScanBtn.classList.add("secondary");
      }
    }

    function setCalibrateInstruction() {
      const digitStr = DIGIT_ORDER[currentDigitIndex];
      const entry = calibration[digitStr];
      const already = entry && entry.samples ? entry.samples.length : 0;
      const sampleNumber = already + 1;

      if (already < SAMPLES_PER_DIGIT) {
        calibrateInstruction.textContent =
          "Leg nu het cijfer " + digitStr + " op het scherm (meting " + sampleNumber + " van " + SAMPLES_PER_DIGIT + ")";
        calibrateSubInstruction.textContent =
          "Draai of verplaats het cijfer een beetje bij elke meting. Raak het scherm alleen met het houten cijfer.";
        statusLabel.textContent =
          "Kalibreren, cijfer " + digitStr + ", meting " + sampleNumber + " van " + SAMPLES_PER_DIGIT + ".";
      } else {
        calibrateInstruction.textContent =
          "Cijfer " + digitStr + " heeft al " + SAMPLES_PER_DIGIT + " metingen.";
        calibrateSubInstruction.textContent =
          "Je kunt opnieuw kalibreren of naar het volgende cijfer gaan.";
      }
    }

    function markDigitCaptured(digitStr, sampleNumber) {
      calibrateInstruction.textContent =
        "Cijfer " + digitStr + " meting " + sampleNumber + " vastgelegd, haal het cijfer van het scherm.";
      calibrateSubInstruction.textContent =
        "Wacht tot het scherm geen aanrakingen meer heeft.";
      statusLabel.textContent =
        "Cijfer " + digitStr + " meting " + sampleNumber + " vastgelegd. Wacht tot het scherm vrij is.";
    }

    function checkCalibrationComplete() {
      return DIGIT_ORDER.every(d => {
        const entry = calibration[d];
        return entry && Array.isArray(entry.samples) && entry.samples.length >= SAMPLES_PER_DIGIT;
      });
    }

    function handleAfterRelease() {
      if (checkCalibrationComplete()) {
        calibrationComplete = true;
        toScanBtn.disabled = false;
        recomputeAdaptiveThreshold();
        safeSaveCalibration();
        calibrateInstruction.textContent = "Kalibratie compleet.";
        calibrateSubInstruction.textContent = "Je kunt nu naar scannen gaan of opnieuw kalibreren.";
        statusLabel.textContent = "Kalibratie voltooid voor alle cijfers.";
        return;
      }

      // anders doorgaan met volgende meting of volgende cijfer
      const currentDigit = DIGIT_ORDER[currentDigitIndex];
      const entry = calibration[currentDigit];
      const countForDigit = entry && entry.samples ? entry.samples.length : 0;

      if (countForDigit < SAMPLES_PER_DIGIT) {
        setCalibrateInstruction();
        return;
      }

      if (currentDigitIndex < DIGIT_ORDER.length - 1) {
        currentDigitIndex += 1;
        setCalibrateInstruction();
      } else {
        // laatste cijfer maar nog niet overal genoeg samples
        calibrateInstruction.textContent = "Kalibratie bijna compleet.";
        calibrateSubInstruction.textContent = "Controleer of alle cijfers genoeg metingen hebben.";
        statusLabel.textContent = "Niet alle cijfers hebben " + SAMPLES_PER_DIGIT + " metingen.";
      }
    }

    function resetCalibrationState(clearStorage) {
      calibration = {};
      calibrationComplete = false;
      currentDigitIndex = 0;
      waitingForRelease = false;
      stableCandidate = null;
      lastPrediction = null;
      MATCH_THRESHOLD = 0.55;

      toScanBtn.disabled = true;
      predictedDigitEl.textContent = "?";
      scanResultLabel.textContent = "Wachten op drie aanrakingen";
      scanStatusLabel.textContent = "Leg een gekalibreerd cijfer op het scherm.";
      updateDebugPanel(null, null, null);

      if (clearStorage) {
        try {
          localStorage.removeItem(LOCAL_STORAGE_KEY);
        } catch (e) {}
        refreshDataTextarea();
      }

      if (mode === "calibrate") {
        setCalibrateInstruction();
      }
    }

    function setPrediction(digitStr, distance, isAmbiguous) {
      if (!digitStr || isAmbiguous) {
        predictedDigitEl.textContent = "?";
        scanResultLabel.textContent = isAmbiguous ? "Twijfelachtige meting" : "Onbekend";
        if (Number.isFinite(distance)) {
          scanStatusLabel.textContent = "Afstand tot beste kalibratie: " + distance.toFixed(3);
        } else {
          scanStatusLabel.textContent = "Leg een gekalibreerd cijfer op het scherm.";
        }
        lastPrediction = null;
        return;
      }

      predictedDigitEl.textContent = digitStr;
      scanResultLabel.textContent = "Herkenning: " + digitStr;
      scanStatusLabel.textContent = "Afstand tot kalibratie: " + distance.toFixed(3);

      if (lastPrediction !== digitStr) {
        lastPrediction = digitStr;
        speakDigit(digitStr);
      }
    }

    function clearPrediction() {
      predictedDigitEl.textContent = "?";
      scanResultLabel.textContent = "Wachten op drie aanrakingen";
      scanStatusLabel.textContent = "Leg een gekalibreerd cijfer op het scherm.";
      lastPrediction = null;
    }

    function touchesToPoints(touchList) {
      const arr = [];
      for (let i = 0; i < touchList.length; i++) {
        const t = touchList.item(i);
        arr.push({
          id: t.identifier,
          x: t.clientX,
          y: t.clientY
        });
      }
      return arr;
    }

    function idsFromPoints(points) {
      return points.map(p => p.id).sort();
    }

    function sameIds(pointsA, pointsB) {
      if (!pointsA || !pointsB || pointsA.length !== pointsB.length) {
        return false;
      }
      const idsA = idsFromPoints(pointsA);
      const idsB = idsFromPoints(pointsB);
      for (let i = 0; i < idsA.length; i++) {
        if (idsA[i] !== idsB[i]) {
          return false;
        }
      }
      return true;
    }

    function maxMovement(pointsNow, pointsOrigin) {
      if (!pointsNow || !pointsOrigin || pointsNow.length !== pointsOrigin.length) {
        return Number.POSITIVE_INFINITY;
      }
      let maxMove = 0;
      for (let i = 0; i < pointsNow.length; i++) {
        const pNow = pointsNow[i];
        let origin = pointsOrigin.find(p => p.id === pNow.id);
        if (!origin) {
          origin = pointsOrigin[i];
        }
        const d = distance(pNow, origin);
        if (d > maxMove) {
          maxMove = d;
        }
      }
      return maxMove;
    }

    function handleStableThreePoints(points) {
      const purePoints = points.map(p => ({ x: p.x, y: p.y }));
      const features = computeFeatures(purePoints);

      if (mode === "calibrate") {
        if (calibrationComplete) {
          return;
        }
        const digitStr = DIGIT_ORDER[currentDigitIndex];
        const existing = calibration[digitStr] || {
          digit: parseInt(digitStr, 10),
          samples: []
        };
        existing.samples.push({
          points: purePoints,
          features: features
        });
        calibration[digitStr] = existing;

        const sampleNumber = existing.samples.length;
        markDigitCaptured(digitStr, sampleNumber);
        waitingForRelease = true;
        updateDebugPanel(purePoints, features, null);
        refreshDataTextarea();

      } else if (mode === "scan") {
        if (!calibrationComplete) {
          statusLabel.textContent = "Scannen is niet beschikbaar. Kalibreer eerst alle cijfers.";
          clearPrediction();
          return;
        }
        const match = findBestMatch(features, calibration);
        const bestDigit = match.digit;
        const bestDist = match.distance;
        const second = match.secondBest;
        const margin = Number.isFinite(second) ? (second - bestDist) : 1;

        updateDebugPanel(purePoints, features, match);

        if (!bestDigit || !Number.isFinite(bestDist)) {
          statusLabel.textContent = "Geen bruikbare match gevonden.";
          setPrediction(null, bestDist, false);
          return;
        }

        const isTooFar = bestDist > MATCH_THRESHOLD;
        const isAmbiguous = margin < AMBIGUITY_MARGIN;

        if (isTooFar) {
          statusLabel.textContent = "Vorm komt onvoldoende overeen met de kalibratie.";
          setPrediction(null, bestDist, false);
        } else if (isAmbiguous) {
          statusLabel.textContent = "Metingen zijn te twijfelachtig, verplaats het cijfer een beetje en probeer opnieuw.";
          setPrediction(null, bestDist, true);
        } else {
          statusLabel.textContent = "Cijfer " + bestDigit + " herkend.";
          setPrediction(bestDigit, bestDist, false);
        }
      }
    }

    function processTouches(touches) {
      const now = performance.now();
      const count = touches.length;

      if (mode === "calibrate") {
        if (waitingForRelease) {
          if (count === 0) {
            waitingForRelease = false;
            handleAfterRelease();
          }
          return;
        }
        if (calibrationComplete) {
          return;
        }
      } else if (mode === "scan") {
        if (!calibrationComplete) {
          clearPrediction();
        }
      }

      if (count !== 3) {
        stableCandidate = null;
        if (mode === "scan" && count === 0) {
          clearPrediction();
        }
        return;
      }

      if (!stableCandidate || !sameIds(touches, stableCandidate.originPoints)) {
        stableCandidate = {
          originPoints: clonePoints(touches),
          startTime: now,
          lastPoints: clonePoints(touches),
          triggered: false
        };
        if (mode === "scan") {
          scanStatusLabel.textContent = "Metingen worden gestabiliseerd.";
        } else {
          statusLabel.textContent = "Metingen worden gestabiliseerd voor dit cijfer.";
        }
        return;
      }

      const move = maxMovement(touches, stableCandidate.originPoints);
      if (move > MOVE_TOLERANCE_PX) {
        stableCandidate = {
          originPoints: clonePoints(touches),
          startTime: now,
          lastPoints: clonePoints(touches),
          triggered: false
        };
        return;
      }

      if (!stableCandidate.triggered && now - stableCandidate.startTime >= STABLE_TIME_MS) {
        stableCandidate.triggered = true;
        handleStableThreePoints(touches);
      }
    }

    function onTouchChange(evt) {
      if (evt.touches && evt.touches.length > 0) {
        evt.preventDefault();
      }
      const touches = touchesToPoints(evt.touches);
      processTouches(touches);
    }

    function onTouchEndOrCancel(evt) {
      if (evt.touches && evt.touches.length > 0) {
        evt.preventDefault();
      }
      const touches = touchesToPoints(evt.touches);
      processTouches(touches);
    }

    // Kopieer kalibratiegegevens naar klembord
    function copyCalibrationToClipboard() {
      const text = JSON.stringify(calibration, null, 2);
      if (!text || text === "{}") {
        statusLabel.textContent = "Er staan nog geen kalibratiegegevens in de app.";
        return;
      }

      const fallbackCopy = function () {
        refreshDataTextarea();
        dataSection.classList.remove("hidden");
        dataTextarea.focus();
        dataTextarea.select();
        try {
          const ok = document.execCommand("copy");
          statusLabel.textContent = ok
            ? "Kalibratiegegevens gekopieerd (fallback)."
            : "Kon niet automatisch kopiëren. Selecteer en kopieer de tekst zelf.";
        } catch (e) {
          statusLabel.textContent = "Kon niet automatisch kopiëren. Selecteer en kopieer de tekst zelf.";
        }
      };

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text)
          .then(function () {
            statusLabel.textContent = "Kalibratiegegevens gekopieerd naar klembord.";
          })
          .catch(function () {
            fallbackCopy();
          });
      } else {
        fallbackCopy();
      }
    }

    // Knoppen
    toCalibrateBtn.addEventListener("click", function () {
      mode = "calibrate";
      updateModeUI();
      if (!calibrationComplete) {
        setCalibrateInstruction();
      } else {
        statusLabel.textContent = "Je zit in kalibreer modus. Je kunt opnieuw kalibreren of naar scannen gaan.";
      }
    });

    toScanBtn.addEventListener("click", function () {
      if (!calibrationComplete) {
        statusLabel.textContent = "Scannen is niet beschikbaar. Kalibreer eerst alle cijfers.";
        return;
      }
      mode = "scan";
      updateModeUI();
      clearPrediction();
      statusLabel.textContent = "Scan modus. Leg een gekalibreerd cijfer met drie contactpunten op het scherm.";
    });

    recalibrateBtn.addEventListener("click", function () {
      resetCalibrationState(false);
      statusLabel.textContent = "Kalibratie opnieuw gestart. Leg het cijfer 0 op het scherm.";
      if (mode !== "calibrate") {
        mode = "calibrate";
        updateModeUI();
      }
    });

    resetBtn.addEventListener("click", function () {
      resetCalibrationState(true);
      statusLabel.textContent = "Kalibratie gewist. Start opnieuw bij cijfer 0.";
      if (mode !== "calibrate") {
        mode = "calibrate";
        updateModeUI();
      }
    });

    showDataBtn.addEventListener("click", function () {
      const willShow = dataSection.classList.contains("hidden");
      if (willShow) {
        refreshDataTextarea();
        dataSection.classList.remove("hidden");
        showDataBtn.textContent = "Verberg kalibratiegegevens";
      } else {
        dataSection.classList.add("hidden");
        showDataBtn.textContent = "Toon kalibratiegegevens";
      }
    });

    copyDataBtn.addEventListener("click", function () {
      copyCalibrationToClipboard();
    });

    touchArea.addEventListener("touchstart", onTouchChange, { passive: false });
    touchArea.addEventListener("touchmove", onTouchChange, { passive: false });
    touchArea.addEventListener("touchend", onTouchEndOrCancel, { passive: false });
    touchArea.addEventListener("touchcancel", onTouchEndOrCancel, { passive: false });

    // Start
    resetCalibrationState(false);
    safeLoadCalibration();
    updateModeUI();
    if (calibrationComplete) {
      refreshDataTextarea();
    } else {
      setCalibrateInstruction();
    }
  })();
</script>
</body>
</html>
