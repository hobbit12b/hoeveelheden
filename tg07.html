<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Pak het juiste cijfer</title>

  <style>
    :root{
      --bg-left:#fdeeea;
      --brand:#e58c74;
      --dash:#f5b498;
      --text:#6f6b68;

      --dash-w:4px;
      --card-radius:28px;

      --digit-size: clamp(190px, 20vw, 340px);
      --fairy-size: clamp(240px, 22vw, 420px);

      --explosion-scale: 2.1;
      --explosion-hide-after: 2.2s;
      --explosion-fadeout: 220ms;

      --digit-fade: 900ms;
      --explosion-pop: 350ms;
      --fairy-pop: 250ms;

      /* Posities binnen de kaart */
      --fairy-left: 22%;
      --fairy-top: 74%;

      --digit-left: 63%;
      --digit-top: 60%;

      --explosion-left: 48%;
      --explosion-top: 58%;

      --shadow: 0 16px 40px rgba(0,0,0,0.08);
    }

    *{ box-sizing:border-box; }

    html, body{
      height:100%;
      margin:0;
      padding:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:#ffffff;
      color: var(--text);
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
      overflow:hidden;
    }

    body{
      display:flex;
    }

    .left{
      flex: 1 1 68%;
      background: var(--bg-left);
      padding: 28px 28px 22px 28px;
      display:flex;
      flex-direction:column;
      gap: 22px;
    }

    .right{
      flex: 1 1 32%;
      background:#ffffff;
      border-left: 6px dashed rgba(245,180,152,0.85);
      padding: 26px;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      min-width: 320px;
    }

    .topbar{
      display:flex;
      align-items:center;
      gap: 22px;
    }

    .homeBtn{
      width:72px;
      height:72px;
      border-radius:18px;
      background: #f8c3b0;
      border: none;
      box-shadow: 0 8px 18px rgba(0,0,0,0.10);
      display:grid;
      place-items:center;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .homeBtn:active{ transform: scale(0.98); }

    .homeIcon{ width:36px; height:36px; }

    .titlePill{
      padding: 18px 44px;
      border-radius: 22px;
      background: var(--brand);
      color: #ffffff;
      font-weight: 800;
      font-size: clamp(22px, 2.2vw, 34px);
      letter-spacing: 0.3px;
      box-shadow: var(--shadow);
      line-height: 1;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height: 64px;
      width: min(620px, 100%);
    }

    .content{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 10px 6px;
    }

    .gameCard{
      width: min(920px, 100%);
      height: min(470px, 55vh);
      background: transparent;
      border: var(--dash-w) dashed rgba(245,180,152,0.85);
      border-radius: var(--card-radius);
      position:relative;
      overflow: visible;
    }

    .earBtn{
      position:absolute;
      right: -36px;
      top: -36px;
      width: 132px;
      height: 132px;
      border-radius: 999px;
      border: 4px solid rgba(245,180,152,0.95);
      background: var(--bg-left);
      box-shadow: 0 12px 30px rgba(0,0,0,0.10);
      display:grid;
      place-items:center;
      cursor:pointer;
      z-index: 30;
      -webkit-tap-highlight-color: transparent;
    }

    .earBtn:active{ transform: scale(0.98); }

    .earBtn span{
      font-size: 56px;
      transform: translateY(2px);
    }

    .stage{
      position:absolute;
      inset: 0;
      overflow: visible;
    }

    .stage img,
    .stage video{
      position:absolute;
      height:auto;
      display:block;
      pointer-events:none;
      transform: translate(-50%, -50%);
    }

    #fairyVid{
      left: var(--fairy-left);
      top: var(--fairy-top);
      width: var(--fairy-size);
      opacity: 0;
      z-index: 1;
    }

    #digitImg{
      left: var(--digit-left);
      top: var(--digit-top);
      width: var(--digit-size);
      opacity: 0;
      z-index: 2;
    }

    #explosion{
      left: var(--explosion-left);
      top: var(--explosion-top);
      width: calc(var(--digit-size) * var(--explosion-scale));
      opacity: 0;
      z-index: 3;
    }

    .stage.play #digitImg{
      animation: appear var(--digit-fade) ease forwards;
    }

    .stage.play #explosion{
      animation: pop var(--explosion-pop) ease forwards;
    }

    .stage.play #fairyVid{
      animation: popFairy var(--fairy-pop) ease forwards;
    }

    @keyframes appear{
      0%{ opacity:0; transform: translate(-50%, -50%) scale(0.96); }
      100%{ opacity:1; transform: translate(-50%, -50%) scale(1); }
    }

    @keyframes pop{
      0%{ opacity:0; transform: translate(-50%, -50%) scale(0.98); }
      100%{ opacity:1; transform: translate(-50%, -50%) scale(1); }
    }

    @keyframes popFairy{
      0%{ opacity:0; transform: translate(-50%, -50%) scale(0.98); }
      100%{ opacity:1; transform: translate(-50%, -50%) scale(1); }
    }

    .scanUI{
      width: min(420px, 100%);
      text-align:center;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 14px;
    }

    .miniTile{
      width: 66px;
      height: 66px;
      border-radius: 10px;
      background: #78abff;
      box-shadow: 0 10px 22px rgba(0,0,0,0.10);
      display:grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      color:#fff;
      font-weight: 900;
      font-size: 20px;
      line-height: 1;
      place-items:center;
      user-select:none;
    }

    .scanTitle{
      font-size: clamp(20px, 1.8vw, 28px);
      font-weight: 700;
      color: #7b7876;
    }

    .scanSub{
      font-size: clamp(15px, 1.3vw, 20px);
      color: rgba(123,120,118,0.75);
    }

    .scanBox{
      width: 100%;
      height: 52vh;
      max-height: 520px;
      border-radius: 22px;
      border: 4px solid rgba(0,0,0,0.06);
      background: #ffffff;
      box-shadow: 0 12px 26px rgba(0,0,0,0.08);
      position: relative;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      touch-action: none;
    }

    .scanStatusPill{
      position:absolute;
      top: 10px;
      right: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      display:flex;
      align-items:center;
      gap: 8px;
      background: rgba(0,0,0,0.04);
      backdrop-filter: blur(8px);
    }

    .scanVisual{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 10px;
      opacity: 0.9;
      pointer-events:none;
    }

    .scanIconMain{ font-size: 42px; }
    .scanLabel{ font-size: 16px; color: rgba(0,0,0,0.58); }

    .scanBox[data-state="idle"] { border-color: rgba(0,0,0,0.10); }
    .scanBox[data-state="scanning"] { border-color: #42a5f5; box-shadow: 0 0 0 4px rgba(66,165,245,0.16), 0 12px 26px rgba(0,0,0,0.10); }
    .scanBox[data-state="success"] { border-color: #66bb6a; box-shadow: 0 0 0 4px rgba(102,187,106,0.18), 0 12px 26px rgba(0,0,0,0.10); }

    .right.wrong{
      animation: wiggle 240ms ease;
    }

    @keyframes wiggle{
      0%{ transform: translateX(0); }
      25%{ transform: translateX(-8px); }
      55%{ transform: translateX(7px); }
      100%{ transform: translateX(0); }
    }

    .startOverlay{
      position:fixed;
      inset:0;
      background: rgba(253,238,234,0.78);
      backdrop-filter: blur(2px);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index: 999;
      padding: 24px;
    }

    .startCard{
      width: min(560px, 92vw);
      background: #ffffff;
      border-radius: 24px;
      box-shadow: var(--shadow);
      padding: 22px 20px;
      text-align:center;
    }

    .startCard h1{
      margin: 0 0 10px 0;
      font-size: 28px;
      color: #4d4a48;
    }

    .startCard p{
      margin: 0 0 16px 0;
      color: rgba(77,74,72,0.82);
      font-size: 18px;
      line-height: 1.35;
    }

    .startBtn{
      appearance:none;
      border:none;
      background: var(--brand);
      color:#fff;
      font-weight: 800;
      padding: 14px 18px;
      border-radius: 18px;
      font-size: 18px;
      cursor:pointer;
      box-shadow: 0 14px 26px rgba(0,0,0,0.12);
      -webkit-tap-highlight-color: transparent;
    }

    .startBtn:active{ transform: scale(0.99); }

    .calibration-warning{
      position: fixed;
      left: 50%;
      bottom: 0.9rem;
      transform: translateX(-50%);
      padding: 0.4rem 0.9rem;
      border-radius: 999px;
      background: rgba(255,255,255,0.96);
      box-shadow: 0 6px 18px rgba(0,0,0,0.22);
      font-size: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
      z-index: 40;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }

    .calibration-warning.visible{
      opacity: 1;
      pointer-events: auto;
    }

    @media (max-width: 900px){
      body{ flex-direction:column; }
      .right{ border-left:none; border-top: 6px dashed rgba(245,180,152,0.85); min-width: unset; }
      .scanBox{ height: 40vh; }
    }
  </style>
</head>

<body>
  <section class="left" aria-label="Spel">
    <div class="topbar">
      <button class="homeBtn" id="homeBtn" aria-label="Naar het menu">
        <svg class="homeIcon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M3 10.6L12 3l9 7.6" stroke="#cf6d55" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M6.5 10.7V21h11V10.7" stroke="#cf6d55" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M9 21v-7h6v7" stroke="#cf6d55" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>

      <div class="titlePill">pak het juiste cijfer</div>
    </div>

    <div class="content">
      <div class="gameCard" aria-label="Toverkaart">
        <button class="earBtn" id="earBtn" aria-label="Nog een keer luisteren"><span aria-hidden="true">üëÇ</span></button>

        <div class="stage" id="stage">
          <video id="fairyVid" muted playsinline preload="auto" aria-label="Toverfee video"></video>
          <img id="digitImg" alt="" />
          <img id="explosion" src="explosie.gif" alt="Explosie" />
        </div>
      </div>
    </div>
  </section>

  <section class="right" id="rightPane" aria-label="Scanvak">
    <div class="scanUI">
      <div class="miniTile" aria-hidden="true">
        <div>1</div><div>2</div><div>3</div><div>4</div>
      </div>

      <div class="scanTitle">Leg het houten cijfer in het vak.</div>
      <div class="scanSub">Alle puntjes in het vak.</div>

      <div class="scanBox" id="scan-box" data-state="idle" aria-label="Scanvak">
        <div class="scanStatusPill">
          <span id="scan-status-icon">‚¨ö</span>
          <span id="scan-status-text" style="font-weight:700; letter-spacing:0.08em; font-size:11px; text-transform:uppercase;">Rustig</span>
        </div>

        <div class="scanVisual" id="scan-visual">
          <div class="scanIconMain" id="scan-icon-main">üëâüî¢</div>
          <div class="scanLabel" id="scan-label">Leg het cijfer hier</div>
        </div>
      </div>

      <div style="font-size:13px; color:rgba(0,0,0,0.55);">
        üì± Blokje stil laten liggen in het vak
      </div>
    </div>
  </section>

  <div class="startOverlay" id="startOverlay" role="dialog" aria-modal="true" aria-label="Start">
    <div class="startCard">
      <h1>Tik om te starten</h1>
      <p>Je hoort een cijfer, leg dat cijfer in het scanvak, met het oortje hoor je het nog eens.</p>
      <button class="startBtn" id="startBtn">Start</button>
    </div>
  </div>

  <div class="calibration-warning" id="calibration-warning">
    <span>‚ö†Ô∏è</span>
    <span>Kalibratie nodig, vraag de leerkracht om hulp</span>
  </div>

  <script>
    /*
      Benodigde bestanden in dezelfde map:
      calibration.json
      marbotic0.png tot en met marbotic9.png
      explosie.gif
      toverfee.mp4
    */

    const DIGIT_WORDS_NL = ['nul','een','twee','drie','vier','vijf','zes','zeven','acht','negen'];
    const ASSET_DIGIT = (d) => `marbotic${d}.png`;
    const FAIRY_SRC = 'toverfee.mp4';

    const stage = document.getElementById('stage');
    const digitImg = document.getElementById('digitImg');
    const explosion = document.getElementById('explosion');
    const fairyVid = document.getElementById('fairyVid');

    const earBtn = document.getElementById('earBtn');
    const homeBtn = document.getElementById('homeBtn');

    const rightPane = document.getElementById('rightPane');
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');

    const scanBoxEl = document.getElementById("scan-box");
    const scanStatusIconEl = document.getElementById("scan-status-icon");
    const scanStatusTextEl = document.getElementById("scan-status-text");
    const scanIconMainEl = document.getElementById("scan-icon-main");
    const scanLabelEl = document.getElementById("scan-label");
    const calibrationWarningEl = document.getElementById("calibration-warning");

    // Globale scanvariabelen (uit jouw werkende spel)
    let calibrationData = null;
    let calibration = null;
    let classificationStats = null;
    let expectedTouchPoints = 3;

    let currentPoints = [];
    let scanState = "idle";
    let measurementLock = false;

    // Spelvariabelen
    let started = false;
    let locked = false;
    let targetDigit = 0;
    let lastScanAt = 0;

    // ---------- Kleine helpers ----------
    function restartGif(img) {
      const base = img.dataset.baseSrc || img.getAttribute('src');
      img.dataset.baseSrc = base;
      const bust = (base.includes('?') ? '&' : '?') + 't=' + Date.now();
      img.setAttribute('src', base + bust);
    }

    function getVarSeconds(name, fallbackSeconds) {
      const raw = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      if (!raw) return fallbackSeconds;
      if (raw.endsWith('ms')) return parseFloat(raw) / 1000;
      if (raw.endsWith('s')) return parseFloat(raw);
      const n = parseFloat(raw);
      return Number.isFinite(n) ? n : fallbackSeconds;
    }

    function getVarMillis(name, fallbackMs) {
      const raw = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      if (!raw) return fallbackMs;
      if (raw.endsWith('ms')) return parseFloat(raw);
      if (raw.endsWith('s')) return parseFloat(raw) * 1000;
      const n = parseFloat(raw);
      return Number.isFinite(n) ? n : fallbackMs;
    }

    function fadeOutAndHide(img, delaySeconds, fadeMs) {
      window.setTimeout(() => {
        const cs = getComputedStyle(img);
        img.style.opacity = cs.opacity;

        img.style.animation = 'none';
        void img.offsetHeight;

        img.style.transition = `opacity ${fadeMs}ms ease`;
        void img.offsetHeight;

        img.style.opacity = '0';

        window.setTimeout(() => {
          img.style.transition = '';
        }, Math.max(0, fadeMs + 80));
      }, Math.max(0, delaySeconds * 1000));
    }

    function freezeOnLastFrame(video) {
      const d = Number.isFinite(video.duration) ? video.duration : 0;
      const t = Math.max(0, d - 0.04);

      const onSeeked = () => video.pause();
      video.addEventListener('seeked', onSeeked, { once: true });

      try { video.currentTime = t; } catch (e) { video.pause(); }
    }

    function preloadDigits(){
      for (let d = 0; d <= 9; d++) {
        const img = new Image();
        img.src = ASSET_DIGIT(d);
      }
    }

    function speakDigit(digit){
      const word = DIGIT_WORDS_NL[digit] ?? String(digit);
      if (!('speechSynthesis' in window)) return;

      try {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(word);
        u.lang = 'nl-NL';
        u.rate = 0.92;
        u.pitch = 1.05;
        window.speechSynthesis.speak(u);
      } catch (e) {}
    }

    function chooseNextDigit(){
      const prev = targetDigit;
      let next = Math.floor(Math.random() * 10);
      if (next === prev) next = (next + 1) % 10;
      targetDigit = next;
    }

    function updateScanState(newState) {
      scanState = newState;
      scanBoxEl.dataset.state = newState;

      if (newState === "idle") {
        scanStatusIconEl.textContent = "‚¨ö";
        scanStatusTextEl.textContent = "Rustig";
        scanIconMainEl.textContent = "üëâüî¢";
        scanLabelEl.textContent = "Leg het cijfer hier";
      } else if (newState === "scanning") {
        scanStatusIconEl.textContent = "üëÜ";
        scanStatusTextEl.textContent = "Scannen";
        scanIconMainEl.textContent = "‚úãüî¢";
        scanLabelEl.textContent = "Blokje even stil laten liggen";
      } else if (newState === "success") {
        scanStatusIconEl.textContent = "‚úÖ";
        scanStatusTextEl.textContent = "Goed";
        scanIconMainEl.textContent = "üéâ";
        scanLabelEl.textContent = "Knap gedaan";
      }
    }

    function wrongFeedback(){
      rightPane.classList.remove('wrong');
      void rightPane.offsetHeight;
      rightPane.classList.add('wrong');
    }

    // ---------- Animatie bij goed ----------
    function clearCard(){
      stage.classList.remove('play');

      digitImg.style.opacity = '0';
      digitImg.removeAttribute('src');
      digitImg.alt = '';

      explosion.style.opacity = '0';

      fairyVid.style.opacity = '0';
    }

    function playSuccessAnimation(digit){
      clearCard();

      digitImg.src = ASSET_DIGIT(digit);
      digitImg.alt = String(digit);

      restartGif(explosion);

      // Video klaarzetten en afspelen
      try { fairyVid.currentTime = 0; } catch (e) {}
      fairyVid.loop = false;
      fairyVid.controls = false;

      fairyVid.onended = () => freezeOnLastFrame(fairyVid);
      fairyVid.onerror = () => { fairyVid.style.opacity = '0'; };

      fairyVid.play().catch(() => {});

      void stage.offsetHeight;
      stage.classList.add('play');

      const hideAfter = getVarSeconds('--explosion-hide-after', 2.2);
      fadeOutAndHide(explosion, hideAfter, getVarMillis('--explosion-fadeout', 220));
    }

    function nextRound(){
      locked = false;
      clearCard();
      updateScanState("idle");
      chooseNextDigit();
      speakDigit(targetDigit);
    }

    // ---------- Start ----------
    function startGame(){
      if (started) return;
      started = true;
      startOverlay.style.display = 'none';

      preloadDigits();

      // Video vooraf laden, door de starttik lukt dit op iPad beter
      fairyVid.src = FAIRY_SRC;
      fairyVid.load();

      // Probeer even te spelen en te pauzeren, zodat de eerste frames ‚Äúklaar‚Äù zijn
      fairyVid.play()
        .then(() => {
          fairyVid.pause();
          try { fairyVid.currentTime = 0; } catch (e) {}
        })
        .catch(() => {});

      nextRound();
    }

    // ---------- KALIBRATIE LADEN ----------
    function loadCalibration() {
      fetch("calibration.json", { cache: "no-store" })
        .then(response => {
          if (!response.ok) throw new Error("Kon calibration.json niet laden");
          return response.json();
        })
        .then(data => {
          calibrationData = data;
          expectedTouchPoints = typeof data.expectedTouchPoints === "number" ? data.expectedTouchPoints : 3;
          calibration = buildCalibrationFromData(data);
          classificationStats = calibration.classificationStats;
          hideCalibrationWarning();
        })
        .catch(error => {
          console.error(error);
          showCalibrationWarning();
        });
    }

    function showCalibrationWarning() {
      calibrationWarningEl.classList.add("visible");
    }

    function hideCalibrationWarning() {
      calibrationWarningEl.classList.remove("visible");
    }

    // ---------- TOUCHAFHANDELING (scan) ----------
    function getTouchesInScanBox(touchEvent) {
      const rect = scanBoxEl.getBoundingClientRect();
      const touches = [];

      for (let i = 0; i < touchEvent.touches.length; i += 1) {
        const t = touchEvent.touches[i];
        const x = t.clientX - rect.left;
        const y = t.clientY - rect.top;

        if (x >= 0 && y >= 0 && x <= rect.width && y <= rect.height) {
          touches.push({ x, y });
        }
      }

      return { rect, touches };
    }

    function handleRecognitionResult(recognizedDigit) {
      if (recognizedDigit == null) return;
      if (!started || locked) return;

      const now = Date.now();
      if (now - lastScanAt < 450) return;
      lastScanAt = now;

      if (recognizedDigit === targetDigit) {
        locked = true;
        updateScanState("success");
        playSuccessAnimation(recognizedDigit);

        window.setTimeout(() => {
          nextRound();
        }, 1800);
      } else {
        wrongFeedback();
      }
    }

    function handleTouch(event) {
      if (!calibration || !classificationStats) return;

      event.preventDefault();
      const result = getTouchesInScanBox(event);
      const touches = result.touches;

      if (touches.length === 0) {
        currentPoints = [];
        updateScanState("idle");
        measurementLock = false;
        return;
      }

      if (touches.length === expectedTouchPoints) {
        currentPoints = touches.map(p => ({ x: p.x, y: p.y }));

        if (!measurementLock) {
          measurementLock = true;
          updateScanState("scanning");

          setTimeout(() => {
            const digit = recognizeDigit(currentPoints);
            handleRecognitionResult(digit);
            measurementLock = false;
          }, 160);
        }
      } else {
        currentPoints = [];
        updateScanState("scanning");
        measurementLock = false;
      }
    }

    scanBoxEl.addEventListener("touchstart", handleTouch, { passive: false });
    scanBoxEl.addEventListener("touchmove", handleTouch, { passive: false });
    scanBoxEl.addEventListener("touchend", handleTouch, { passive: false });
    scanBoxEl.addEventListener("touchcancel", handleTouch, { passive: false });

    // ---------- HERKENNINGSMODULE (ongewijzigd uit jouw werkende spel) ----------
    function computeFeatures(points) {
      if (!points || points.length !== 3) return null;

      const p0 = points[0];
      const p1 = points[1];
      const p2 = points[2];

      const dx01 = p1.x - p0.x;
      const dy01 = p1.y - p0.y;
      const dx12 = p2.x - p1.x;
      const dy12 = p2.y - p1.y;

      const d01 = Math.hypot(dx01, dy01);
      const d12 = Math.hypot(dx12, dy12);
      const d20 = Math.hypot(p0.x - p2.x, p0.y - p2.y);

      const distances = [d01, d12, d20].sort((a, b) => a - b);
      const longest = distances[2] || 1e-6;
      const ratioSmall = distances[0] / longest;
      const ratioMid = distances[1] / longest;

      const dot = dx01 * dx12 + dy01 * dy12;
      const len01 = d01 || 1e-6;
      const len12 = d12 || 1e-6;
      let cosAngle = dot / (len01 * len12);
      if (cosAngle > 1) cosAngle = 1;
      if (cosAngle < -1) cosAngle = -1;

      const cross = dx01 * dy12 - dy01 * dx12;
      const orientation = cross >= 0 ? 1 : -1;

      const cx = (p0.x + p1.x + p2.x) / 3;
      const cy = (p0.y + p1.y + p2.y) / 3;

      const minX = Math.min(p0.x, p1.x, p2.x);
      const maxX = Math.max(p0.x, p1.x, p2.x);
      const minY = Math.min(p0.y, p1.y, p2.y);
      const maxY = Math.max(p0.y, p1.y, p2.y);
      const width = maxX - minX || 1e-6;
      const height = maxY - minY || 1e-6;
      const aspect = width / height;

      return { ratioSmall, ratioMid, cosAngle, orientation, centroidX: cx, centroidY: cy, aspect };
    }

    function buildFeatureVector(features) {
      if (!features) return null;

      const weights = {
        ratioSmall: 2.0,
        ratioMid: 2.0,
        cosAngle: 1.2,
        orientation: 0.5,
        centroidX: 0.25,
        centroidY: 0.25,
        aspect: 1.0
      };

      return [
        features.ratioSmall * weights.ratioSmall,
        features.ratioMid * weights.ratioMid,
        features.cosAngle * weights.cosAngle,
        features.orientation * weights.orientation,
        features.centroidX * weights.centroidX * 0.01,
        features.centroidY * weights.centroidY * 0.01,
        features.aspect * weights.aspect
      ];
    }

    function vectorDistance(a, b) {
      let sum = 0;
      const len = Math.min(a.length, b.length);
      for (let i = 0; i < len; i += 1) {
        const d = a[i] - b[i];
        sum += d * d;
      }
      return Math.sqrt(sum);
    }

    function buildCalibrationFromData(data) {
      const calibration = { digits: {}, allSamples: [], classificationStats: null };
      const expected = typeof data.expectedTouchPoints === "number" ? data.expectedTouchPoints : 3;

      for (const key in data) {
        if (!Object.prototype.hasOwnProperty.call(data, key)) continue;
        if (!/^[0-9]$/.test(key)) continue;

        const entry = data[key];
        if (!entry || !Array.isArray(entry.samples)) continue;

        const digit = Number(key);
        const digitBucket = { digit, samples: [] };

        entry.samples.forEach(sample => {
          if (!sample || !Array.isArray(sample.points)) return;
          if (sample.points.length !== expected) return;

          const pts = sample.points.map(p => ({ x: p.x, y: p.y }));
          const features = computeFeatures(pts);
          const vector = buildFeatureVector(features);
          if (!features || !vector) return;

          const sampleObj = { digit, points: pts, features, vector };
          digitBucket.samples.push(sampleObj);
          calibration.allSamples.push(sampleObj);
        });

        if (digitBucket.samples.length > 0) {
          calibration.digits[key] = digitBucket;
        }
      }

      calibration.classificationStats = recomputeClassificationStats(calibration);
      return calibration;
    }

    function recomputeClassificationStats(calibration) {
      const samples = calibration.allSamples || [];
      const sameDistances = [];
      const diffDistances = [];

      for (let i = 0; i < samples.length; i += 1) {
        for (let j = i + 1; j < samples.length; j += 1) {
          const sa = samples[i];
          const sb = samples[j];
          const dist = vectorDistance(sa.vector, sb.vector);
          if (sa.digit === sb.digit) sameDistances.push(dist);
          else diffDistances.push(dist);
        }
      }

      function stats(arr) {
        if (!arr.length) return { mean: 0, std: 0, min: 0, max: 0 };
        const sum = arr.reduce((a, b) => a + b, 0);
        const mean = sum / arr.length;
        const variance = arr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / arr.length;
        const std = Math.sqrt(variance);
        const min = Math.min.apply(null, arr);
        const max = Math.max.apply(null, arr);
        return { mean, std, min, max };
      }

      const sameStats = stats(sameDistances);
      const diffStats = stats(diffDistances);

      let thresholdBase;
      let thresholdUnknown;

      if (sameDistances.length > 0) thresholdBase = sameStats.mean + sameStats.std * 1.5;
      else thresholdBase = 0.18;

      if (diffDistances.length > 0) thresholdUnknown = (sameStats.mean + diffStats.mean) / 2;
      else thresholdUnknown = thresholdBase * 1.8;

      if (thresholdUnknown < thresholdBase) thresholdUnknown = thresholdBase * 1.6;

      return { thresholdBase, thresholdUnknown, sameStats, diffStats };
    }

    function classifyMeasurement(measurementVector, calibration, stats) {
      const allSamples = calibration.allSamples || [];
      let bestDigit = null;
      let bestDistance = Infinity;

      for (let i = 0; i < allSamples.length; i += 1) {
        const sample = allSamples[i];
        const dist = vectorDistance(measurementVector, sample.vector);
        if (dist < bestDistance) {
          bestDistance = dist;
          bestDigit = sample.digit;
        }
      }

      if (bestDigit == null) return { digit: null, distance: bestDistance, certainty: "unknown" };

      let certainty = "unknown";
      if (bestDistance <= stats.thresholdBase) certainty = "certain";
      else if (bestDistance <= stats.thresholdUnknown) certainty = "uncertain";
      else certainty = "unknown";

      return { digit: bestDigit, distance: bestDistance, certainty };
    }

    function recognizeDigit(points) {
      if (!calibration || !classificationStats) return null;
      if (!points || points.length !== expectedTouchPoints) return null;

      const features = computeFeatures(points);
      const vector = buildFeatureVector(features);
      if (!features || !vector) return null;

      const result = classifyMeasurement(vector, calibration, classificationStats);
      if (!result || result.digit == null) return null;
      if (result.certainty !== "certain") return null;

      return result.digit;
    }

    // ---------- UI knoppen ----------
    earBtn.addEventListener('click', () => {
      if (!started) startGame();
      else speakDigit(targetDigit);
    });

    startBtn.addEventListener('click', startGame);
    startOverlay.addEventListener('click', (e) => {
      if (e.target === startOverlay) startGame();
    });

    homeBtn.addEventListener('click', () => {
      try { window.location.href = 'index.html'; } catch (e) {}
    });

    // ---------- INIT ----------
    window.addEventListener("load", () => {
      loadCalibration();
      clearCard();
      updateScanState("idle");
    });
  </script>
</body>
</html>
