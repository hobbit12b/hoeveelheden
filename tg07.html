<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>Marbotic - TG07 Luister & Leg</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root{
      --bg-top:#f4f1ff;
      --bg-bottom:#fef6e9;
      --shadow:0 10px 25px rgba(0,0,0,0.08);

      --scan-border-neutral:rgba(255,255,255,0.8);
      --scan-border-scan:rgba(255,255,255,0.9);
      --scan-border-good:#4caf50;
      --scan-border-bad:#e53935;

      --scan-bg-neutral:rgba(255,255,255,0.12);
      --scan-bg-scan:rgba(255,255,255,0.22);
      --scan-bg-good:rgba(76,175,80,0.18);
      --scan-bg-bad:rgba(229,57,53,0.18);

      --text:#333;
      --text-soft:#666;
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html,body{ height:100%; margin:0; padding:0; }
    body{
      font-family:-apple-system,BlinkMacSystemFont,system-ui,sans-serif;
      background:linear-gradient(to bottom,var(--bg-top),var(--bg-bottom));
      color:var(--text);
      display:flex;
      justify-content:center;
      align-items:stretch;
      touch-action:none;
      -webkit-user-select:none;
      user-select:none;
      -webkit-touch-callout:none;
    }

    .game{
      width:100%;
      max-width:900px;
      min-height:100vh;
      padding:clamp(12px,3vh,24px);
      display:flex;
      flex-direction:column;
      gap:10px;
      padding-top:calc(clamp(12px,3vh,24px) + env(safe-area-inset-top));
      padding-bottom:calc(clamp(12px,3vh,24px) + env(safe-area-inset-bottom));
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .home-btn{
      width:54px;
      height:54px;
      border-radius:18px;
      background:rgba(255,255,255,0.75);
      box-shadow:0 4px 12px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.6rem;
      text-decoration:none;
      color:inherit;
      flex:0 0 auto;
    }
    .home-btn:active{ transform:scale(0.98); }

    .title-badge{
      flex:1 1 auto;
      background:rgba(255,255,255,0.75);
      border-radius:999px;
      padding:10px 14px;
      box-shadow:0 4px 12px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      min-height:54px;
      cursor:pointer;
      -webkit-user-select:none;
      user-select:none;
    }
    .title-icon{ font-size:1.35rem; }
    .title-text{ font-size:1rem; font-weight:800; letter-spacing:.02em; white-space:nowrap; }

    .level-chip{
      width:54px;
      height:54px;
      border-radius:18px;
      background:rgba(255,255,255,0.75);
      box-shadow:0 4px 12px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.3rem;
      flex:0 0 auto;
    }

    .main{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
    }

    .stage{
      width:min(86vw, 520px);
      aspect-ratio: 4 / 3;
      border-radius:34px;
      box-shadow:var(--shadow);
      background:rgba(255,255,255,0.75);
      position:relative;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      border:4px solid rgba(255,255,255,0.6);
    }

    .reveal{
      width:100%;
      height:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:10px;
      padding:16px;
    }

    .reveal-digit{
      width:min(55%, 260px);
      aspect-ratio: 1 / 1;
      border-radius:28px;
      background:#fff;
      box-shadow:0 10px 22px rgba(0,0,0,0.10);
      background-repeat:no-repeat;
      background-position:center;
      background-size:contain;
      border:4px solid transparent;
    }

    .reveal-mark{
      font-size:min(18vw, 92px);
      line-height:1;
      transform:translateY(-2px);
      opacity:0.98;
    }

    .curtains{
      position:absolute;
      inset:0;
      display:flex;
      pointer-events:none;
    }
    .curtain{
      width:50%;
      height:100%;
      background-image:url('gordijnen.gif');
      background-size:cover;
      background-repeat:no-repeat;
      will-change:transform;
      transition:transform 0.55s cubic-bezier(.2,.8,.2,1);
      filter:saturate(1.05) contrast(1.05);
    }
    .curtain.left{ background-position:left center; transform:translateX(0); }
    .curtain.right{ background-position:right center; transform:translateX(0); }
    .curtains.open .curtain.left{ transform:translateX(-102%); }
    .curtains.open .curtain.right{ transform:translateX(102%); }

    .sparkle{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:min(22vw, 120px);
      opacity:0;
      transform:scale(0.92);
      transition:opacity .22s ease-out, transform .22s ease-out;
      pointer-events:none;
    }
    .sparkle.show{ opacity:1; transform:scale(1); }

    .hint-row{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      color:var(--text-soft);
      font-weight:800;
      background:rgba(255,255,255,0.55);
      border-radius:999px;
      padding:10px 14px;
      box-shadow:0 4px 12px rgba(0,0,0,0.05);
    }
    .hint-ico{ font-size:1.35rem; }

    .progress{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:center;
      padding:8px 12px;
      background:rgba(255,255,255,0.55);
      border-radius:999px;
      box-shadow:0 4px 12px rgba(0,0,0,0.05);
      flex-wrap:wrap;
      max-width:min(86vw, 520px);
    }
    .pip{
      width:14px; height:14px;
      border-radius:999px;
      background:rgba(0,0,0,0.14);
      opacity:0.75;
      transition:transform .16s ease-out, opacity .16s ease-out, background .16s ease-out;
    }
    .pip.on{
      opacity:1;
      transform:scale(1.12);
      background:rgba(0,0,0,0.30);
    }

    .footer{
      flex:1 1 auto;
      display:flex;
      flex-direction:column;
    }

    .scan-area{
      border-radius:28px;
      border-width:4px;
      border-style:dashed;
      border-color:var(--scan-border-neutral);
      background:var(--scan-bg-neutral);
      flex:1 1 auto;
      min-height:55vh;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow:0 10px 22px rgba(0,0,0,0.12);
      transition:border-color .18s ease-out, background .18s ease-out, box-shadow .18s ease-out, transform .12s ease-out;
      position:relative;
      overflow:hidden;
      margin-top:6px;
    }

    .scan-area-inner{
      text-align:center;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      pointer-events:none;
    }
    .scan-icon{ font-size:2.4rem; animation:pulse 2s ease-in-out infinite; }
    @keyframes pulse{ 0%{transform:scale(1);opacity:.9} 100%{transform:scale(1.08);opacity:1} }
    .scan-text{ font-size:1.05rem; color:var(--text-soft); }
    .scan-hint{ font-size:0.85rem; color:rgba(0,0,0,0.48); }

    .scan-area.state-neutral{ border-style:dashed; border-color:var(--scan-border-neutral); background:var(--scan-bg-neutral); transform:translateY(0); }
    .scan-area.state-scanning{ border-style:solid; border-color:var(--scan-border-scan); background:var(--scan-bg-scan); box-shadow:0 12px 26px rgba(0,0,0,0.16); transform:translateY(-2px); }
    .scan-area.state-correct{ border-style:solid; border-color:var(--scan-border-good); background:var(--scan-bg-good); box-shadow:0 12px 30px rgba(76,175,80,0.35); transform:translateY(-2px); }
    .scan-area.state-wrong{ border-style:solid; border-color:var(--scan-border-bad); background:var(--scan-bg-bad); box-shadow:0 12px 30px rgba(229,57,53,0.35); transform:translateY(-2px); }

    @media (max-width: 600px){
      .home-btn, .level-chip{ width:50px; height:50px; border-radius:16px; }
      .title-text{ font-size:0.95rem; }
      .stage{ border-radius:30px; }
      .reveal-digit{ border-radius:24px; }
      .pip{ width:13px; height:13px; }
    }
  </style>
</head>
<body>
  <div class="game" id="game" data-level="1">
    <header>
      <a class="home-btn" href="index.html" aria-label="Terug naar start">üè†</a>

      <div class="title-badge" id="title-badge" role="button" aria-label="Luister nog een keer">
        <span class="title-icon">üîä</span>
        <span class="title-text">Luister & leg</span>
      </div>

      <div class="level-chip" id="level-chip" aria-label="Level">üå±</div>
    </header>

    <main class="main">
      <div class="stage" aria-label="Podium">
        <div class="reveal" aria-hidden="true">
          <div class="reveal-digit" id="reveal-digit"></div>
          <div class="reveal-mark" id="reveal-mark">üé≠</div>
        </div>

        <div class="curtains" id="curtains" aria-hidden="true">
          <div class="curtain left"></div>
          <div class="curtain right"></div>
        </div>

        <div class="sparkle" id="sparkle">‚≠ê</div>
      </div>

      <div class="hint-row" aria-label="Hint">
        <span class="hint-ico">üëÇ</span>
        <span>Tik op üîä en leg het cijfer</span>
      </div>

      <div class="progress" id="progress" aria-label="Voortgang"></div>
    </main>

    <footer class="footer">
      <div class="scan-area state-neutral" id="scan-area" aria-label="Scanvak">
        <div class="scan-area-inner">
          <div class="scan-icon">üîé</div>
          <div class="scan-text">In het vak graag</div>
          <div class="scan-hint">Alle puntjes in het vak</div>
        </div>
      </div>
    </footer>
  </div>

  <script>
    /* ================================
       MARBOTIC HERKENNINGSMODULE
       (logica ongewijzigd)
       ================================ */

    const DIGIT_ORDER = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

    let calibration = null;
    let classificationStats = null;
    let expectedTouchPoints = 3;

    function initCalibration(calibrationData) {
      if (!calibrationData || typeof calibrationData !== "object") {
        calibration = null;
        classificationStats = null;
        expectedTouchPoints = 3;
        return;
      }

      if (typeof calibrationData.expectedTouchPoints === "number") {
        expectedTouchPoints = calibrationData.expectedTouchPoints;
      } else {
        expectedTouchPoints = 3;
      }

      calibration = buildCalibrationFromData(calibrationData);
      recomputeClassificationStats();
    }

    function buildCalibrationFromData(data) {
      const obj = {};
      DIGIT_ORDER.forEach(function (d) {
        obj[String(d)] = { digit: d, samples: [] };
      });

      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        const entry = data[key];
        if (!entry || !Array.isArray(entry.samples)) return;

        entry.samples.forEach(function (s) {
          if (!s || !Array.isArray(s.points) || s.points.length !== 3) return;

          const pts = s.points.map(function (p) {
            return { x: Number(p.x), y: Number(p.y) };
          });

          const features = computeFeatures(pts);
          obj[key].samples.push({ points: pts, features: features });
        });
      });

      return obj;
    }

    function computeFeatures(points) {
      if (!points || points.length !== 3) {
        return {
          sides: [0, 0, 0],
          orientation: 0,
          cosAngle: 0,
          centroid: { x: 0, y: 0 },
          yNorm: [0, 0, 0],
          xPattern: [0, 0, 0],
          aspect: 0,
          vector: [0, 0, 0]
        };
      }

      const p0 = points[0];
      const p1 = points[1];
      const p2 = points[2];

      const centroidRaw = {
        x: (p0.x + p1.x + p2.x) / 3,
        y: (p0.y + p1.y + p2.y) / 3
      };

      const isoPoints = [p0, p1, p2].map(function (p) {
        const dx = p.x - centroidRaw.x;
        const dy = p.y - centroidRaw.y;
        return { x: dx, y: dy };
      });

      let maxDist = 0;
      for (let i = 0; i < isoPoints.length; i++) {
        const q = isoPoints[i];
        const d = Math.sqrt(q.x * q.x + q.y * q.y);
        if (d > maxDist) maxDist = d;
      }
      if (maxDist < 1e-6) maxDist = 1;

      for (let i = 0; i < isoPoints.length; i++) {
        isoPoints[i].x /= maxDist;
        isoPoints[i].y /= maxDist;
      }

      function dist(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.sqrt(dx * dx + dy * dy);
      }

      const L01 = dist(isoPoints[0], isoPoints[1]);
      const L12 = dist(isoPoints[1], isoPoints[2]);
      const L20 = dist(isoPoints[2], isoPoints[0]);

      const sides = [
        { len: L01, i: 0, j: 1 },
        { len: L12, i: 1, j: 2 },
        { len: L20, i: 2, j: 0 }
      ];
      const maxSideLen = Math.max(L01, L12, L20) || 1;
      const sidesNormSorted = sides
        .slice()
        .sort(function (a, b) { return a.len - b.len; })
        .map(function (s) { return s.len / maxSideLen; });

      const largest = sides
        .slice()
        .sort(function (a, b) { return a.len - b.len; })[2];

      const A = isoPoints[largest.i];
      const B = isoPoints[largest.j];
      const CIndex = 3 - largest.i - largest.j;
      const C = isoPoints[CIndex];

      function orientationVal(a, b, c) {
        const value =
          (b.x - a.x) * (c.y - a.y) -
          (b.y - a.y) * (c.x - a.x);
        if (value > 0) return 1;
        if (value < 0) return -1;
        return 0;
      }

      const orientation = orientationVal(A, B, C);

      const AC = dist(A, C);
      const BC = dist(B, C);
      const AB = largest.len;
      const AC2 = AC * AC;
      const BC2 = BC * BC;
      const AB2 = AB * AB;
      let cosAngle = 0;
      const denom = 2 * AC * BC;
      if (denom > 1e-6) {
        cosAngle = (AC2 + BC2 - AB2) / denom;
      }

      let minX = Math.min(p0.x, p1.x, p2.x);
      let maxX = Math.max(p0.x, p1.x, p2.x);
      let minY = Math.min(p0.y, p1.y, p2.y);
      let maxY = Math.max(p0.y, p1.y, p2.y);
      let width = maxX - minX;
      let height = maxY - minY;
      if (width < 1e-6) width = 1;
      if (height < 1e-6) height = 1;

      const yNormVals = [p0, p1, p2]
        .map(function (p) { return (p.y - minY) / height; })
        .sort(function (a, b) { return a - b; });

      const pointsWithIndex = [
        { p: p0, idx: 0 },
        { p: p1, idx: 1 },
        { p: p2, idx: 2 }
      ].sort(function (a, b) { return a.p.y - b.p.y; });

      const xPattern = pointsWithIndex.map(function (item) {
        return (item.p.x - minX) / width;
      });

      const aspect = height / (width + height);

      const centroidBox = {
        x: (centroidRaw.x - minX) / width,
        y: (centroidRaw.y - minY) / height
      };

      const vector = buildFeatureVector({
        sides: sidesNormSorted,
        orientation: orientation,
        cosAngle: cosAngle,
        centroid: centroidBox,
        yNorm: yNormVals,
        xPattern: xPattern,
        aspect: aspect
      });

      return {
        sides: sidesNormSorted,
        orientation: orientation,
        cosAngle: cosAngle,
        centroid: centroidBox,
        yNorm: yNormVals,
        xPattern: xPattern,
        aspect: aspect,
        vector: vector
      };
    }

    function buildFeatureVector(f) {
      const wSides = 3.0;
      const wCos = 4.0;
      const wOrient = 2.0;
      const wY = 3.0;
      const wX = 2.0;
      const wAspect = 2.0;

      const v = [];
      v.push(f.sides[0] * wSides);
      v.push(f.sides[1] * wSides);
      v.push(f.sides[2] * wSides);

      v.push(f.cosAngle * wCos);
      v.push(f.orientation * wOrient);

      v.push(f.yNorm[0] * wY);
      v.push(f.yNorm[1] * wY);
      v.push(f.yNorm[2] * wY);

      v.push(f.xPattern[0] * wX);
      v.push(f.xPattern[1] * wX);
      v.push(f.xPattern[2] * wX);

      v.push(f.aspect * wAspect);

      return v;
    }

    function vectorDistance(a, b) {
      if (!a || !b || a.length !== b.length) return Infinity;
      let sum = 0;
      for (let i = 0; i < a.length; i++) {
        const diff = a[i] - b[i];
        sum += diff * diff;
      }
      return Math.sqrt(sum);
    }

    function recomputeClassificationStats() {
      if (!calibration) {
        classificationStats = { thresholdBase: 0.8, thresholdUnknown: 1.5 };
        return;
      }

      const allSamples = [];
      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        if (!calibration[key]) return;
        const samples = calibration[key].samples || [];
        samples.forEach(function (s) {
          allSamples.push({ digit: d, features: s.features });
        });
      });

      if (allSamples.length < 2) {
        classificationStats = { thresholdBase: 0.6, thresholdUnknown: 1.0 };
        return;
      }

      const sameMinDistances = [];
      const betweenMinDistances = [];

      for (let i = 0; i < allSamples.length; i++) {
        const a = allSamples[i];
        const vecA = a.features.vector;
        let minSame = Infinity;
        let minOther = Infinity;

        for (let j = 0; j < allSamples.length; j++) {
          if (i === j) continue;
          const b = allSamples[j];
          const vecB = b.features.vector;
          const dist = vectorDistance(vecA, vecB);

          if (a.digit === b.digit) {
            if (dist < minSame) minSame = dist;
          } else {
            if (dist < minOther) minOther = dist;
          }
        }

        if (minSame < Infinity) sameMinDistances.push(minSame);
        if (minOther < Infinity) betweenMinDistances.push(minOther);
      }

      if (sameMinDistances.length === 0 || betweenMinDistances.length === 0) {
        classificationStats = { thresholdBase: 0.7, thresholdUnknown: 1.2 };
        return;
      }

      const maxSame = Math.max.apply(null, sameMinDistances);
      const minBetween = Math.min.apply(null, betweenMinDistances);

      let thresholdBase;
      if (minBetween > maxSame) thresholdBase = (maxSame + minBetween) / 2;
      else thresholdBase = maxSame * 1.3;

      const thresholdUnknown = thresholdBase * 1.5;

      classificationStats = {
        thresholdBase: thresholdBase,
        thresholdUnknown: thresholdUnknown,
        maxSame: maxSame,
        minBetween: minBetween
      };
    }

    function classifyMeasurement(features) {
      const vec = features.vector;
      if (!vec || !calibration) {
        return { digit: null, bestDist: null, certainty: "onbekend", isUnknown: true, topMatches: [] };
      }

      const bestPerDigit = {};
      DIGIT_ORDER.forEach(function (d) { bestPerDigit[d] = Infinity; });

      let bestDigit = null;
      let bestDist = Infinity;

      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        const entry = calibration[key];
        if (!entry) return;
        const samples = entry.samples || [];
        for (let i = 0; i < samples.length; i++) {
          const sampleVec = samples[i].features.vector;
          const dist = vectorDistance(vec, sampleVec);
          if (dist < bestPerDigit[d]) bestPerDigit[d] = dist;
          if (dist < bestDist) { bestDist = dist; bestDigit = d; }
        }
      });

      const perDigitArray = [];
      DIGIT_ORDER.forEach(function (d) {
        const val = bestPerDigit[d];
        if (val < Infinity) perDigitArray.push({ digit: d, distance: val });
      });
      perDigitArray.sort(function (a, b) { return a.distance - b.distance; });
      const topMatches = perDigitArray.slice(0, 3);

      if (bestDigit === null || bestDist === Infinity) {
        return { digit: null, bestDist: null, certainty: "onbekend", isUnknown: true, topMatches: topMatches };
      }

      let stats = classificationStats || { thresholdBase: 0.8, thresholdUnknown: 1.5 };
      const base = stats.thresholdBase;
      const unknownThresh = stats.thresholdUnknown;

      let isUnknown = false;
      let certainty = "zeker";

      if (bestDist > unknownThresh) isUnknown = true;
      else if (bestDist > base) certainty = "twijfelachtig";

      if (!isUnknown && topMatches.length > 1) {
        const second = topMatches[1].distance;
        if (second > 0) {
          const ratio = bestDist / second;
          if (ratio > 0.9 && certainty === "zeker") certainty = "twijfelachtig";
        }
      }

      return {
        digit: isUnknown ? null : bestDigit,
        bestDist: bestDist,
        certainty: certainty,
        isUnknown: isUnknown,
        topMatches: topMatches
      };
    }

    function recognizeDigit(points) {
      if (!calibration || !classificationStats) return null;
      if (!Array.isArray(points) || points.length !== expectedTouchPoints) return null;

      const features = computeFeatures(points);
      const classification = classifyMeasurement(features);

      if (!classification || classification.isUnknown || classification.digit == null) return null;
      return classification.digit;
    }

    /* ================================
       TG07: LUISTER & LEG (met gordijn)
       ================================ */

    const DIGIT_IMAGE_PREFIX = "marbotic";
    const DIGIT_IMAGE_SUFFIX = ".png";

    const NUMBER_WORDS = {
      0: "nul",
      1: "√©√©n",
      2: "twee",
      3: "drie",
      4: "vier",
      5: "vijf",
      6: "zes",
      7: "zeven",
      8: "acht",
      9: "negen"
    };

    let audioCtx = null;
    function ensureAudio(){
      if (!audioCtx){
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) audioCtx = new AC();
      }
      if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
    }
    function playTone(freq, duration){
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.frequency.value = freq;
      osc.type = "sine";
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.22, now + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      osc.start(now);
      osc.stop(now + duration + 0.05);
    }
    function sfxGood(){ playTone(880, 0.14); setTimeout(function(){ playTone(1175, 0.16); }, 120); }
    function sfxBad(){ playTone(220, 0.20); }

    // Temporary spoken audio (Dutch TTS)
    let preferredVoice = null;
    function pickDutchVoice(){
      if (!("speechSynthesis" in window)) return null;
      const voices = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : [];
      if (!voices || voices.length === 0) return null;
      for (let i=0;i<voices.length;i++){
        const v = voices[i];
        if ((v.lang || "").toLowerCase().startsWith("nl")) return v;
      }
      return null;
    }
    function ensureVoice(){
      if (!("speechSynthesis" in window)) return;
      if (!preferredVoice) preferredVoice = pickDutchVoice();
    }
    if ("speechSynthesis" in window){
      window.speechSynthesis.onvoiceschanged = function(){ preferredVoice = pickDutchVoice(); };
      ensureVoice();
    }
    function speak(text){
      if (!("speechSynthesis" in window)) return;
      try{ window.speechSynthesis.cancel(); }catch(e){}
      ensureVoice();
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "nl-NL";
      if (preferredVoice) u.voice = preferredVoice;
      u.rate = 0.95;
      u.pitch = 1.05;
      try{ window.speechSynthesis.speak(u); }catch(e){}
    }
    function sayPrompt(digit){
      const w = NUMBER_WORDS[digit] || String(digit);
      speak("Zoek de " + w + ".");
    }
    function sayGood(digit){
      const w = NUMBER_WORDS[digit] || String(digit);
      speak("Goed zo! Dat is " + w + "!");
    }
    function sayTryAgain(digit){
      const w = NUMBER_WORDS[digit] || String(digit);
      speak("Oeps. Zoek de " + w + ".");
    }
    function sayLevelUp(){ speak("Goed gedaan! Volgende level!"); }

    function shuffle(arr){
      const a = arr.slice();
      for (let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        const t = a[i]; a[i]=a[j]; a[j]=t;
      }
      return a;
    }

    document.addEventListener("DOMContentLoaded", function(){
      const gameEl = document.getElementById("game");
      const scanArea = document.getElementById("scan-area");
      const titleBadge = document.getElementById("title-badge");
      const levelChip = document.getElementById("level-chip");

      const curtains = document.getElementById("curtains");
      const revealDigit = document.getElementById("reveal-digit");
      const revealMark = document.getElementById("reveal-mark");
      const sparkle = document.getElementById("sparkle");
      const progressEl = document.getElementById("progress");

      // Touch/recognition
      let currentPoints = [];
      let hasResultForCurrentTouches = false;

      // Game state
      let started = false;

      let level = 1;
      let levelDigits = [1,2,3,4,5]; // level 1 (no 0)
      let bag = shuffle(levelDigits);
      let mastered = {};             // digit -> true
      let reviewQueue = [];          // {digit, dueAt}
      let roundCount = 0;

      let targetDigit = bag.pop();
      let mistakeThisRound = false;
      let roundActive = true;

      // progress pips
      let pips = [];

      function setScanState(state){
        scanArea.classList.remove("state-neutral","state-scanning","state-correct","state-wrong");
        if (state === "scanning") scanArea.classList.add("state-scanning");
        else if (state === "correct") scanArea.classList.add("state-correct");
        else if (state === "wrong") scanArea.classList.add("state-wrong");
        else scanArea.classList.add("state-neutral");
      }
      function setCurtains(open){ curtains.classList.toggle("open", !!open); }
      function showSparkle(on, glyph){
        if (glyph) sparkle.textContent = glyph;
        sparkle.classList.toggle("show", !!on);
      }
      function setLevelUI(){
        gameEl.dataset.level = String(level);
        levelChip.textContent = (level === 1) ? "üå±" : "üöÄ";
      }
      function buildProgress(){
        progressEl.innerHTML = "";
        pips = [];
        for (let i=0;i<levelDigits.length;i++){
          const pip = document.createElement("div");
          pip.className = "pip";
          progressEl.appendChild(pip);
          pips.push(pip);
        }
      }
      function updateProgress(){
        for (let i=0;i<levelDigits.length;i++){
          const d = levelDigits[i];
          pips[i].classList.toggle("on", !!mastered[d]);
        }
      }
      function setRevealNeutral(){
        revealDigit.style.backgroundImage = "none";
        revealMark.textContent = "üé≠";
      }
      function setRevealForDigit(d){
        revealDigit.style.backgroundImage = "url('" + DIGIT_IMAGE_PREFIX + d + DIGIT_IMAGE_SUFFIX + "')";
      }

      function getDueReview(){
        const due = [];
        for (let i=0;i<reviewQueue.length;i++){
          if (reviewQueue[i].dueAt <= roundCount) due.push({i:i, item: reviewQueue[i]});
        }
        if (due.length === 0) return null;
        const pick = due[Math.floor(Math.random()*due.length)];
        reviewQueue.splice(pick.i, 1);
        return pick.item.digit;
      }

      function getNextTarget(){
        const dueReview = getDueReview();
        if (dueReview !== null){
          if (bag.length === 0 || Math.random() < 0.35){
            return dueReview;
          } else {
            reviewQueue.push({ digit: dueReview, dueAt: roundCount });
          }
        }
        if (bag.length > 0) return bag.pop();
        if (reviewQueue.length > 0){
          reviewQueue.sort(function(a,b){ return a.dueAt - b.dueAt; });
          return reviewQueue.shift().digit;
        }
        return null; // cycle complete
      }

      function maybeLevelUp(){
        if (level !== 1) return false;
        for (let i=0;i<levelDigits.length;i++){
          if (!mastered[levelDigits[i]]) return false;
        }
        if (reviewQueue.length > 0) return false;
        if (bag.length > 0) return false;

        // Level up
        level = 2;
        levelDigits = [0,1,2,3,4,5,6,7,8,9];
        bag = shuffle(levelDigits);
        mastered = {};
        reviewQueue = [];
        roundCount = 0;

        setLevelUI();
        buildProgress();
        updateProgress();

        showSparkle(true, "üéâ");
        sayLevelUp();
        setTimeout(function(){ showSparkle(false); }, 800);
        return true;
      }

      function startRound(nextDigit){
        targetDigit = nextDigit;
        mistakeThisRound = false;
        roundActive = true;
        hasResultForCurrentTouches = false;

        setScanState("neutral");
        setCurtains(false);
        setRevealNeutral();
        showSparkle(false);

        setTimeout(function(){ sayPrompt(targetDigit); }, 80);
      }

      function newRound(){
        const next = getNextTarget();
        if (next === null){
          if (maybeLevelUp()){
            startRound(getNextTarget());
          } else {
            // Level 2 cycle complete -> new cycle
            bag = shuffle(levelDigits);
            mastered = {};
            reviewQueue = [];
            roundCount = 0;
            updateProgress();
            startRound(getNextTarget());
          }
          return;
        }
        startRound(next);
      }

      function handleCorrect(){
        roundActive = false;
        setScanState("correct");
        sfxGood();

        setRevealForDigit(targetDigit);
        revealMark.textContent = "‚úÖ";
        showSparkle(true, "‚≠ê");
        setTimeout(function(){ setCurtains(true); }, 40);

        if (mistakeThisRound){
          reviewQueue.push({ digit: targetDigit, dueAt: roundCount + 3 });
        }

        mastered[targetDigit] = true;
        updateProgress();
        sayGood(targetDigit);

        roundCount += 1;

        setTimeout(function(){
          showSparkle(false);
          setCurtains(false);
          newRound();
        }, 1200);
      }

      function handleWrong(){
        setScanState("wrong");
        sfxBad();
        mistakeThisRound = true;

        setRevealForDigit(targetDigit);
        revealMark.textContent = "üôà";
        showSparkle(true, "üîÅ");
        setTimeout(function(){ setCurtains(true); }, 40);
        setTimeout(function(){ sayTryAgain(targetDigit); }, 180);

        setTimeout(function(){
          showSparkle(false);
          setCurtains(false);
          if (currentPoints.length === 0) setScanState("neutral");
          else setScanState("scanning");
        }, 1200);
      }

      function getPointsFromTouches(touchList){
        const rect = scanArea.getBoundingClientRect();
        const points = [];
        for (let i=0;i<touchList.length;i++){
          const t = touchList[i];
          const x = t.clientX;
          const y = t.clientY;
          if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom){
            points.push({x:x, y:y});
          }
        }
        return points;
      }

      function startIfNeeded(){
        if (started) return;
        started = true;
        ensureAudio();
        startRound(targetDigit);
      }

      function handleTouchEvent(e){
        startIfNeeded();
        ensureAudio();

        const touches = e.touches || [];
        currentPoints = getPointsFromTouches(touches);

        if (currentPoints.length === 0){
          hasResultForCurrentTouches = false;
          setScanState("neutral");
          return;
        }

        setScanState("scanning");

        if (currentPoints.length !== expectedTouchPoints){
          hasResultForCurrentTouches = false;
          return;
        }

        if (!hasResultForCurrentTouches && roundActive){
          const digit = recognizeDigit(currentPoints);
          if (digit !== null && typeof digit === "number"){
            hasResultForCurrentTouches = true;
            if (digit === targetDigit) handleCorrect();
            else handleWrong();
          }
        }
      }

      ["touchstart","touchmove","touchend","touchcancel"].forEach(function(type){
        scanArea.addEventListener(type, handleTouchEvent, {passive:true});
      });

      // Repeat prompt on title badge
      let lastTitleTouch = 0;
      function repeatPrompt(){
        startIfNeeded();
        sayPrompt(targetDigit);
      }
      titleBadge.addEventListener("touchstart", function(){
        lastTitleTouch = Date.now();
        repeatPrompt();
      }, {passive:true});
      titleBadge.addEventListener("click", function(){
        if (Date.now() - lastTitleTouch < 500) return;
        repeatPrompt();
      });

      // Init UI
      setLevelUI();
      buildProgress();
      updateProgress();
      setRevealNeutral();
      setCurtains(false);
      showSparkle(false);

      fetch("calibration.json")
        .then(function(r){ return r.json(); })
        .then(function(data){ initCalibration(data); })
        .catch(function(){});
    });
  </script>
</body>
</html>
