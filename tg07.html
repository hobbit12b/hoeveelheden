<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>Marbotic - TG07 Cijfers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root{
      --bg-top:#f4f1ff;
      --bg-bottom:#fef6e9;
      --card:#ffffff;
      --shadow:0 10px 25px rgba(0,0,0,0.08);
      --accent-soft:#ffe0b2;
      --accent-strong:#ff8a65;

      --scan-border-neutral:rgba(255,255,255,0.8);
      --scan-border-scan:rgba(255,255,255,0.9);
      --scan-border-good:#4caf50;
      --scan-border-bad:#e53935;

      --scan-bg-neutral:rgba(255,255,255,0.12);
      --scan-bg-scan:rgba(255,255,255,0.22);
      --scan-bg-good:rgba(76,175,80,0.18);
      --scan-bg-bad:rgba(229,57,53,0.18);

      --text:#333;
      --text-soft:#666;
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html,body{ height:100%; margin:0; padding:0; }
    body{
      font-family:-apple-system,BlinkMacSystemFont,system-ui,sans-serif;
      background:linear-gradient(to bottom,var(--bg-top),var(--bg-bottom));
      color:var(--text);
      display:flex;
      justify-content:center;
      align-items:stretch;
      touch-action:none;
      -webkit-user-select:none;
      user-select:none;
      -webkit-touch-callout:none;
    }

    .game{
      width:100%;
      max-width:900px;
      min-height:100vh;
      padding:clamp(12px,3vh,24px);
      display:flex;
      flex-direction:column;
      gap:10px;
      padding-top:calc(clamp(12px,3vh,24px) + env(safe-area-inset-top));
      padding-bottom:calc(clamp(12px,3vh,24px) + env(safe-area-inset-bottom));
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .home-btn{
      width:54px;
      height:54px;
      border-radius:18px;
      background:rgba(255,255,255,0.75);
      box-shadow:0 4px 12px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.6rem;
      text-decoration:none;
      color:inherit;
      flex:0 0 auto;
    }
    .home-btn:active{ transform:scale(0.98); }

    .title-badge{
      flex:1 1 auto;
      background:rgba(255,255,255,0.75);
      border-radius:999px;
      padding:10px 14px;
      box-shadow:0 4px 12px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      min-height:54px;
    }
    .title-icon{ font-size:1.4rem; }
    .title-text{ font-size:1rem; font-weight:700; letter-spacing:.02em; white-space:nowrap; }

    .level-chip{
      width:54px;
      height:54px;
      border-radius:18px;
      background:rgba(255,255,255,0.75);
      box-shadow:0 4px 12px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.3rem;
      flex:0 0 auto;
    }

    .main{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
    }

    .target-card{
      width:min(78vw, 420px);
      aspect-ratio: 4 / 3;
      background:var(--card);
      border-radius:34px;
      box-shadow:var(--shadow);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
      border:4px solid transparent;
    }
    .target-inner{
      width:86%;
      height:86%;
      background-repeat:no-repeat;
      background-position:center;
      background-size:contain;
    }

    .hint-row{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      color:var(--text-soft);
      font-weight:700;
    }
    .hint-ico{ font-size:1.4rem; }
    .progress{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:center;
      padding:8px 12px;
      background:rgba(255,255,255,0.55);
      border-radius:999px;
      box-shadow:0 4px 12px rgba(0,0,0,0.05);
    }
    .dot{
      width:14px; height:14px;
      border-radius:999px;
      background:rgba(0,0,0,0.14);
      transform:scale(1);
      transition: transform .16s ease-out, opacity .16s ease-out;
      opacity:0.75;
    }
    .dot.on{
      opacity:1;
      transform:scale(1.12);
      background:rgba(0,0,0,0.28);
    }

    .footer{
      flex:1 1 auto;
      display:flex;
      flex-direction:column;
    }

    .scan-area{
      border-radius:28px;
      border-width:4px;
      border-style:dashed;
      border-color:var(--scan-border-neutral);
      background:var(--scan-bg-neutral);
      flex:1 1 auto;
      min-height:55vh;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow:0 10px 22px rgba(0,0,0,0.12);
      transition:border-color .18s ease-out, background .18s ease-out, box-shadow .18s ease-out, transform .12s ease-out;
      position:relative;
      overflow:hidden;
      margin-top:6px;
    }

    .scan-area-inner{
      text-align:center;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      pointer-events:none;
    }
    .scan-icon{ font-size:2.4rem; animation: pulse 2s ease-in-out infinite; }
    @keyframes pulse{ 0%{transform:scale(1);opacity:.9} 100%{transform:scale(1.08);opacity:1} }
    .scan-text{ font-size:1.05rem; color:var(--text-soft); }
    .scan-hint{ font-size:0.85rem; color:rgba(0,0,0,0.48); }

    .scan-area.state-neutral{ border-style:dashed; border-color:var(--scan-border-neutral); background:var(--scan-bg-neutral); transform:translateY(0); }
    .scan-area.state-scanning{ border-style:solid; border-color:var(--scan-border-scan); background:var(--scan-bg-scan); box-shadow:0 12px 26px rgba(0,0,0,0.16); transform:translateY(-2px); }
    .scan-area.state-correct{ border-style:solid; border-color:var(--scan-border-good); background:var(--scan-bg-good); box-shadow:0 12px 30px rgba(76,175,80,0.35); transform:translateY(-2px); }
    .scan-area.state-wrong{ border-style:solid; border-color:var(--scan-border-bad); background:var(--scan-bg-bad); box-shadow:0 12px 30px rgba(229,57,53,0.35); transform:translateY(-2px); }

    .celebrate{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:min(22vw, 120px);
      opacity:0;
      transform:scale(0.92);
      pointer-events:none;
      transition: opacity .22s ease-out, transform .22s ease-out;
    }
    .celebrate.show{ opacity:1; transform:scale(1); }

    @media (max-width: 600px){
      .home-btn, .level-chip{ width:50px; height:50px; border-radius:16px; }
      .title-text{ font-size:0.95rem; }
      .target-card{ border-radius:30px; }
    }
  </style>
</head>
<body>
  <div class="game" id="game">
    <header>
      <a class="home-btn" href="index.html" aria-label="Terug naar start">üè†</a>
      <div class="title-badge" aria-label="TG07 Cijfers">
        <span class="title-icon">üî¢</span>
        <span class="title-text">Leg hetzelfde cijfer</span>
      </div>
      <div class="level-chip" id="level-chip" aria-label="Level">üå±</div>
    </header>

    <main class="main">
      <div class="target-card" id="target-card" aria-label="Doelcijfer">
        <div class="target-inner" id="target-inner"></div>
        <div class="celebrate" id="celebrate">‚≠ê</div>
      </div>

      <div class="hint-row" aria-label="Hint">
        <span class="hint-ico">üëâ</span>
        <span>Leg het houten cijfer in het vak</span>
      </div>

      <div class="progress" id="progress" aria-label="Reeks goed">
        <!-- 7 dots -->
      </div>
    </main>

    <footer class="footer">
      <div class="scan-area state-neutral" id="scan-area" aria-label="Scanvak">
        <div class="scan-area-inner">
          <div class="scan-icon">üîé</div>
          <div class="scan-text">In het vak graag</div>
          <div class="scan-hint">Alle puntjes in het vak</div>
        </div>
      </div>
    </footer>
  </div>

  <script>
    /* ================================
       MARBOTIC HERKENNINGSMODULE
       (logica ongewijzigd)
       ================================ */

    const DIGIT_ORDER = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

    let calibration = null;
    let classificationStats = null;
    let expectedTouchPoints = 3;

    function initCalibration(calibrationData) {
      if (!calibrationData || typeof calibrationData !== "object") {
        calibration = null;
        classificationStats = null;
        expectedTouchPoints = 3;
        return;
      }

      if (typeof calibrationData.expectedTouchPoints === "number") {
        expectedTouchPoints = calibrationData.expectedTouchPoints;
      } else {
        expectedTouchPoints = 3;
      }

      calibration = buildCalibrationFromData(calibrationData);
      recomputeClassificationStats();
    }

    function buildCalibrationFromData(data) {
      const obj = {};
      DIGIT_ORDER.forEach(function (d) {
        obj[String(d)] = { digit: d, samples: [] };
      });

      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        const entry = data[key];
        if (!entry || !Array.isArray(entry.samples)) return;

        entry.samples.forEach(function (s) {
          if (!s || !Array.isArray(s.points) || s.points.length !== 3) return;

          const pts = s.points.map(function (p) {
            return { x: Number(p.x), y: Number(p.y) };
          });

          const features = computeFeatures(pts);
          obj[key].samples.push({ points: pts, features: features });
        });
      });

      return obj;
    }

    function computeFeatures(points) {
      if (!points || points.length !== 3) {
        return {
          sides: [0, 0, 0],
          orientation: 0,
          cosAngle: 0,
          centroid: { x: 0, y: 0 },
          yNorm: [0, 0, 0],
          xPattern: [0, 0, 0],
          aspect: 0,
          vector: [0, 0, 0]
        };
      }

      const p0 = points[0];
      const p1 = points[1];
      const p2 = points[2];

      const centroidRaw = {
        x: (p0.x + p1.x + p2.x) / 3,
        y: (p0.y + p1.y + p2.y) / 3
      };

      const isoPoints = [p0, p1, p2].map(function (p) {
        const dx = p.x - centroidRaw.x;
        const dy = p.y - centroidRaw.y;
        return { x: dx, y: dy };
      });

      let maxDist = 0;
      for (let i = 0; i < isoPoints.length; i++) {
        const q = isoPoints[i];
        const d = Math.sqrt(q.x * q.x + q.y * q.y);
        if (d > maxDist) maxDist = d;
      }
      if (maxDist < 1e-6) maxDist = 1;

      for (let i = 0; i < isoPoints.length; i++) {
        isoPoints[i].x /= maxDist;
        isoPoints[i].y /= maxDist;
      }

      function dist(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.sqrt(dx * dx + dy * dy);
      }

      const L01 = dist(isoPoints[0], isoPoints[1]);
      const L12 = dist(isoPoints[1], isoPoints[2]);
      const L20 = dist(isoPoints[2], isoPoints[0]);

      const sides = [
        { len: L01, i: 0, j: 1 },
        { len: L12, i: 1, j: 2 },
        { len: L20, i: 2, j: 0 }
      ];
      const maxSideLen = Math.max(L01, L12, L20) || 1;
      const sidesNormSorted = sides
        .slice()
        .sort(function (a, b) { return a.len - b.len; })
        .map(function (s) { return s.len / maxSideLen; });

      const largest = sides
        .slice()
        .sort(function (a, b) { return a.len - b.len; })[2];

      const A = isoPoints[largest.i];
      const B = isoPoints[largest.j];
      const CIndex = 3 - largest.i - largest.j;
      const C = isoPoints[CIndex];

      function orientationVal(a, b, c) {
        const value =
          (b.x - a.x) * (c.y - a.y) -
          (b.y - a.y) * (c.x - a.x);
        if (value > 0) return 1;
        if (value < 0) return -1;
        return 0;
      }

      const orientation = orientationVal(A, B, C);

      const AC = dist(A, C);
      const BC = dist(B, C);
      const AB = largest.len;
      const AC2 = AC * AC;
      const BC2 = BC * BC;
      const AB2 = AB * AB;
      let cosAngle = 0;
      const denom = 2 * AC * BC;
      if (denom > 1e-6) {
        cosAngle = (AC2 + BC2 - AB2) / denom;
      }

      let minX = Math.min(p0.x, p1.x, p2.x);
      let maxX = Math.max(p0.x, p1.x, p2.x);
      let minY = Math.min(p0.y, p1.y, p2.y);
      let maxY = Math.max(p0.y, p1.y, p2.y);
      let width = maxX - minX;
      let height = maxY - minY;
      if (width < 1e-6) width = 1;
      if (height < 1e-6) height = 1;

      const yNormVals = [p0, p1, p2]
        .map(function (p) { return (p.y - minY) / height; })
        .sort(function (a, b) { return a - b; });

      const pointsWithIndex = [
        { p: p0, idx: 0 },
        { p: p1, idx: 1 },
        { p: p2, idx: 2 }
      ].sort(function (a, b) { return a.p.y - b.p.y; });

      const xPattern = pointsWithIndex.map(function (item) {
        return (item.p.x - minX) / width;
      });

      const aspect = height / (width + height);

      const centroidBox = {
        x: (centroidRaw.x - minX) / width,
        y: (centroidRaw.y - minY) / height
      };

      const vector = buildFeatureVector({
        sides: sidesNormSorted,
        orientation: orientation,
        cosAngle: cosAngle,
        centroid: centroidBox,
        yNorm: yNormVals,
        xPattern: xPattern,
        aspect: aspect
      });

      return {
        sides: sidesNormSorted,
        orientation: orientation,
        cosAngle: cosAngle,
        centroid: centroidBox,
        yNorm: yNormVals,
        xPattern: xPattern,
        aspect: aspect,
        vector: vector
      };
    }

    function buildFeatureVector(f) {
      const wSides = 3.0;
      const wCos = 4.0;
      const wOrient = 2.0;
      const wY = 3.0;
      const wX = 2.0;
      const wAspect = 2.0;

      const v = [];
      v.push(f.sides[0] * wSides);
      v.push(f.sides[1] * wSides);
      v.push(f.sides[2] * wSides);

      v.push(f.cosAngle * wCos);
      v.push(f.orientation * wOrient);

      v.push(f.yNorm[0] * wY);
      v.push(f.yNorm[1] * wY);
      v.push(f.yNorm[2] * wY);

      v.push(f.xPattern[0] * wX);
      v.push(f.xPattern[1] * wX);
      v.push(f.xPattern[2] * wX);

      v.push(f.aspect * wAspect);

      return v;
    }

    function vectorDistance(a, b) {
      if (!a || !b || a.length !== b.length) return Infinity;
      let sum = 0;
      for (let i = 0; i < a.length; i++) {
        const diff = a[i] - b[i];
        sum += diff * diff;
      }
      return Math.sqrt(sum);
    }

    function recomputeClassificationStats() {
      if (!calibration) {
        classificationStats = { thresholdBase: 0.8, thresholdUnknown: 1.5 };
        return;
      }

      const allSamples = [];
      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        if (!calibration[key]) return;
        const samples = calibration[key].samples || [];
        samples.forEach(function (s) {
          allSamples.push({ digit: d, features: s.features });
        });
      });

      if (allSamples.length < 2) {
        classificationStats = { thresholdBase: 0.6, thresholdUnknown: 1.0 };
        return;
      }

      const sameMinDistances = [];
      const betweenMinDistances = [];

      for (let i = 0; i < allSamples.length; i++) {
        const a = allSamples[i];
        const vecA = a.features.vector;
        let minSame = Infinity;
        let minOther = Infinity;

        for (let j = 0; j < allSamples.length; j++) {
          if (i === j) continue;
          const b = allSamples[j];
          const vecB = b.features.vector;
          const dist = vectorDistance(vecA, vecB);

          if (a.digit === b.digit) {
            if (dist < minSame) minSame = dist;
          } else {
            if (dist < minOther) minOther = dist;
          }
        }

        if (minSame < Infinity) sameMinDistances.push(minSame);
        if (minOther < Infinity) betweenMinDistances.push(minOther);
      }

      if (sameMinDistances.length === 0 || betweenMinDistances.length === 0) {
        classificationStats = { thresholdBase: 0.7, thresholdUnknown: 1.2 };
        return;
      }

      const maxSame = Math.max.apply(null, sameMinDistances);
      const minBetween = Math.min.apply(null, betweenMinDistances);

      let thresholdBase;
      if (minBetween > maxSame) thresholdBase = (maxSame + minBetween) / 2;
      else thresholdBase = maxSame * 1.3;

      const thresholdUnknown = thresholdBase * 1.5;

      classificationStats = {
        thresholdBase: thresholdBase,
        thresholdUnknown: thresholdUnknown,
        maxSame: maxSame,
        minBetween: minBetween
      };
    }

    function classifyMeasurement(features) {
      const vec = features.vector;
      if (!vec || !calibration) {
        return { digit: null, bestDist: null, certainty: "onbekend", isUnknown: true, topMatches: [] };
      }

      const bestPerDigit = {};
      DIGIT_ORDER.forEach(function (d) { bestPerDigit[d] = Infinity; });

      let bestDigit = null;
      let bestDist = Infinity;

      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        const entry = calibration[key];
        if (!entry) return;
        const samples = entry.samples || [];
        for (let i = 0; i < samples.length; i++) {
          const sampleVec = samples[i].features.vector;
          const dist = vectorDistance(vec, sampleVec);
          if (dist < bestPerDigit[d]) bestPerDigit[d] = dist;
          if (dist < bestDist) { bestDist = dist; bestDigit = d; }
        }
      });

      const perDigitArray = [];
      DIGIT_ORDER.forEach(function (d) {
        const val = bestPerDigit[d];
        if (val < Infinity) perDigitArray.push({ digit: d, distance: val });
      });
      perDigitArray.sort(function (a, b) { return a.distance - b.distance; });
      const topMatches = perDigitArray.slice(0, 3);

      if (bestDigit === null || bestDist === Infinity) {
        return { digit: null, bestDist: null, certainty: "onbekend", isUnknown: true, topMatches: topMatches };
      }

      let stats = classificationStats || { thresholdBase: 0.8, thresholdUnknown: 1.5 };
      const base = stats.thresholdBase;
      const unknownThresh = stats.thresholdUnknown;

      let isUnknown = false;
      let certainty = "zeker";

      if (bestDist > unknownThresh) isUnknown = true;
      else if (bestDist > base) certainty = "twijfelachtig";

      if (!isUnknown && topMatches.length > 1) {
        const second = topMatches[1].distance;
        if (second > 0) {
          const ratio = bestDist / second;
          if (ratio > 0.9 && certainty === "zeker") certainty = "twijfelachtig";
        }
      }

      return {
        digit: isUnknown ? null : bestDigit,
        bestDist: bestDist,
        certainty: certainty,
        isUnknown: isUnknown,
        topMatches: topMatches
      };
    }

    function recognizeDigit(points) {
      if (!calibration || !classificationStats) return null;
      if (!Array.isArray(points) || points.length !== expectedTouchPoints) return null;

      const features = computeFeatures(points);
      const classification = classifyMeasurement(features);

      if (!classification || classification.isUnknown || classification.digit == null) return null;
      return classification.digit;
    }

    /* ================================
       SPELLOGICA TG07
       - Level 1: 0..5
       - Level 2: 0..9
       - 7x achter elkaar goed -> level omhoog
       ================================ */

    const DIGIT_IMAGE_PREFIX = "marbotic";
    const DIGIT_IMAGE_SUFFIX = ".png";

    const STREAK_TO_LEVEL_UP = 7;

    let audioCtx = null;
    function ensureAudio(){
      if (!audioCtx){
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) audioCtx = new AC();
      }
      if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
    }
    function playTone(freq, duration){
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.frequency.value = freq;
      osc.type = "sine";
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.25, now + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      osc.start(now);
      osc.stop(now + duration + 0.05);
    }
    function sfxGood(){ playTone(880, 0.14); setTimeout(function(){ playTone(1175, 0.16); }, 120); }
    function sfxBad(){ playTone(220, 0.20); }

    document.addEventListener("DOMContentLoaded", function(){
      const scanArea = document.getElementById("scan-area");
      const targetInner = document.getElementById("target-inner");
      const celebrate = document.getElementById("celebrate");
      const levelChip = document.getElementById("level-chip");
      const progressEl = document.getElementById("progress");

      // progress dots
      const dots = [];
      for (let i=0;i<STREAK_TO_LEVEL_UP;i++){
        const d = document.createElement("div");
        d.className = "dot";
        progressEl.appendChild(d);
        dots.push(d);
      }

      function setScanState(state){
        scanArea.classList.remove("state-neutral","state-scanning","state-correct","state-wrong");
        if (state === "scanning") scanArea.classList.add("state-scanning");
        else if (state === "correct") scanArea.classList.add("state-correct");
        else if (state === "wrong") scanArea.classList.add("state-wrong");
        else scanArea.classList.add("state-neutral");
      }

      function setCelebrate(on, glyph){
        if (glyph) celebrate.textContent = glyph;
        celebrate.classList.toggle("show", !!on);
      }

      // game state
      let level = 1; // 1 or 2
      let streak = 0;
      let roundActive = true;

      let allowed = [0,1,2,3,4,5];
      let targetDigit = 0;

      // touch/recognition
      let currentPoints = [];
      let hasResultForCurrentTouches = false;

      function setLevelUI(){
        levelChip.textContent = (level === 1) ? "üå±" : "üöÄ";
      }

      function updateProgress(){
        for (let i=0;i<dots.length;i++){
          dots[i].classList.toggle("on", i < streak);
        }
      }

      function pickNewTarget(){
        const idx = Math.floor(Math.random() * allowed.length);
        targetDigit = allowed[idx];
        targetInner.style.backgroundImage = "url('" + DIGIT_IMAGE_PREFIX + targetDigit + DIGIT_IMAGE_SUFFIX + "')";
      }

      function newRound(){
        roundActive = true;
        hasResultForCurrentTouches = false;
        setCelebrate(false);
        setScanState("neutral");
        pickNewTarget();
      }

      function levelUp(){
        level = 2;
        allowed = [0,1,2,3,4,5,6,7,8,9];
        streak = 0;
        updateProgress();
        setLevelUI();
        setCelebrate(true, "üéâ");
        setTimeout(function(){
          setCelebrate(false);
          newRound();
        }, 900);
      }

      function handleGood(){
        roundActive = false;
        setScanState("correct");
        setCelebrate(true, "‚≠ê");
        sfxGood();

        streak += 1;
        updateProgress();

        if (level === 1 && streak >= STREAK_TO_LEVEL_UP){
          setTimeout(levelUp, 850);
          return;
        }

        // level 2: gewoon door
        setTimeout(function(){
          setCelebrate(false);
          newRound();
        }, 850);
      }

      function handleBad(){
        setScanState("wrong");
        setCelebrate(true, "üôà");
        sfxBad();

        streak = 0;
        updateProgress();

        setTimeout(function(){
          setCelebrate(false);
          if (currentPoints.length === 0) setScanState("neutral");
          else setScanState("scanning");
        }, 450);
      }

      function getPointsFromTouches(touchList){
        const rect = scanArea.getBoundingClientRect();
        const points = [];
        for (let i=0;i<touchList.length;i++){
          const t = touchList[i];
          const x = t.clientX;
          const y = t.clientY;
          if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom){
            points.push({x:x, y:y});
          }
        }
        return points;
      }

      function handleTouchEvent(e){
        ensureAudio();

        const touches = e.touches || [];
        currentPoints = getPointsFromTouches(touches);

        if (currentPoints.length === 0){
          hasResultForCurrentTouches = false;
          setScanState("neutral");
          return;
        }

        // we laten "scannen" zien, maar we beslissen pas bij precies expectedTouchPoints
        setScanState("scanning");

        if (currentPoints.length !== expectedTouchPoints){
          hasResultForCurrentTouches = false;
          return;
        }

        if (!hasResultForCurrentTouches && roundActive){
          const digit = recognizeDigit(currentPoints);
          if (digit !== null && typeof digit === "number"){
            hasResultForCurrentTouches = true;
            if (digit === targetDigit) handleGood();
            else handleBad();
          }
        }
      }

      ["touchstart","touchmove","touchend","touchcancel"].forEach(function(type){
        scanArea.addEventListener(type, handleTouchEvent, {passive:true});
      });

      // init
      setLevelUI();
      updateProgress();
      newRound();

      fetch("calibration.json")
        .then(function(r){ return r.json(); })
        .then(function(data){ initCalibration(data); })
        .catch(function(){ /* geen debug in UI */ });
    });
  </script>
</body>
</html>
