<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Pak het juiste cijfer</title>

  <style>
    :root{
      --bg-left:#fdeeea;
      --brand:#e58c74;
      --dash:#f5b498;
      --text:#6f6b68;

      --dash-w:4px;
      --card-radius:28px;

      --digit-size: clamp(190px, 20vw, 340px);
      --fairy-size: clamp(260px, 23vw, 460px);

      --explosion-scale: 2.1;
      --explosion-hide-after: 2.2s;
      --explosion-fadeout: 220ms;

      --digit-fade: 900ms;
      --explosion-pop: 350ms;
      --fairy-pop: 250ms;

      /* Posities binnen de kaart */
      --fairy-left: 28%;
      --fairy-top: 70%;

      --digit-left: 63%;
      --digit-top: 58%;

      --explosion-left: 50%;
      --explosion-top: 58%;

      --shadow: 0 16px 40px rgba(0,0,0,0.08);

      /* Scanvak stijl */
      --scan-border-neutral: rgba(255,255,255,0.85);
      --scan-border-scan: rgba(255,255,255,0.95);
      --scan-border-good: #4caf50;

      --scan-bg-neutral: rgba(255,255,255,0.12);
      --scan-bg-scan: rgba(255,255,255,0.22);
      --scan-bg-good: rgba(76,175,80,0.18);
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }

    html, body{
      height:100%;
      margin:0;
      padding:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:#ffffff;
      color: var(--text);
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
      overflow:hidden;
    }

    body{ display:flex; }

    .left{
      flex: 1 1 68%;
      background: var(--bg-left);
      padding: 28px 28px 22px 28px;
      display:flex;
      flex-direction:column;
      gap: 22px;
    }

    .right{
      flex: 1 1 32%;
      background:#ffffff;
      border-left: 6px dashed rgba(245,180,152,0.85);
      padding: 26px;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      min-width: 320px;
    }

    .topbar{
      display:flex;
      align-items:center;
      gap: 22px;
    }

    .homeBtn{
      width:72px;
      height:72px;
      border-radius:18px;
      background: #f8c3b0;
      border: none;
      box-shadow: 0 8px 18px rgba(0,0,0,0.10);
      display:grid;
      place-items:center;
      cursor:pointer;
    }
    .homeBtn:active{ transform: scale(0.98); }
    .homeIcon{ width:36px; height:36px; }

    .titlePill{
      padding: 18px 44px;
      border-radius: 22px;
      background: var(--brand);
      color: #ffffff;
      font-weight: 800;
      font-size: clamp(22px, 2.2vw, 34px);
      letter-spacing: 0.3px;
      box-shadow: var(--shadow);
      line-height: 1;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height: 64px;
      width: min(620px, 100%);
    }

    .content{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 10px 6px;
    }

    .gameCard{
      width: min(920px, 100%);
      height: min(470px, 55vh);
      background: transparent;
      border: var(--dash-w) dashed rgba(245,180,152,0.85);
      border-radius: var(--card-radius);
      position:relative;
      overflow: visible;
    }

    .earBtn{
      position:absolute;
      right: -36px;
      top: -36px;
      width: 132px;
      height: 132px;
      border-radius: 999px;
      border: 4px solid rgba(245,180,152,0.95);
      background: var(--bg-left);
      box-shadow: 0 12px 30px rgba(0,0,0,0.10);
      display:grid;
      place-items:center;
      cursor:pointer;
      z-index: 30;
    }
    .earBtn:active{ transform: scale(0.98); }
    .earBtn span{ font-size: 56px; transform: translateY(2px); }

    .stage{
      position:absolute;
      inset: 0;
      overflow: visible;
    }

    .stage img,
    .stage video{
      position:absolute;
      height:auto;
      display:block;
      pointer-events:none;
      transform: translate(-50%, -50%);
    }

    #fairyVid{
      left: var(--fairy-left);
      top: var(--fairy-top);
      width: var(--fairy-size);
      opacity: 0;
      z-index: 1;
    }

    #digitImg{
      left: var(--digit-left);
      top: var(--digit-top);
      width: var(--digit-size);
      opacity: 0;
      z-index: 2;
    }

    #explosion{
      left: var(--explosion-left);
      top: var(--explosion-top);
      width: calc(var(--digit-size) * var(--explosion-scale));
      opacity: 0;
      z-index: 3;
    }

    .stage.play #digitImg{ animation: appear var(--digit-fade) ease forwards; }
    .stage.play #explosion{ animation: pop var(--explosion-pop) ease forwards; }
    .stage.play #fairyVid{ animation: popFairy var(--fairy-pop) ease forwards; }

    @keyframes appear{
      0%{ opacity:0; transform: translate(-50%, -50%) scale(0.96); }
      100%{ opacity:1; transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes pop{
      0%{ opacity:0; transform: translate(-50%, -50%) scale(0.98); }
      100%{ opacity:1; transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes popFairy{
      0%{ opacity:0; transform: translate(-50%, -50%) scale(0.98); }
      100%{ opacity:1; transform: translate(-50%, -50%) scale(1); }
    }

    /* Rechterkant: geen extra binnenvak, alleen het grote scanvak */
    .scanUI{
      width: min(520px, 100%);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 14px;
      text-align:center;
    }

    .miniTile{
      width: 66px;
      height: 66px;
      border-radius: 10px;
      background: #78abff;
      box-shadow: 0 10px 22px rgba(0,0,0,0.10);
      display:grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      color:#fff;
      font-weight: 900;
      font-size: 20px;
      line-height: 1;
      place-items:center;
      user-select:none;
    }

    .scanTitle{
      font-size: clamp(22px, 2vw, 34px);
      font-weight: 800;
      color: #7b7876;
      margin-top: 6px;
    }

    .scanSub{
      font-size: clamp(16px, 1.3vw, 20px);
      color: rgba(123,120,118,0.75);
      margin-top: -4px;
    }

    .scan-area{
      width: 100%;
      border-radius: 28px;
      border-width: 4px;
      border-style: dashed;
      border-color: var(--scan-border-neutral);
      background: var(--scan-bg-neutral);
      min-height: 62vh;
      max-height: 74vh;
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.12);
      transition: border-color 0.18s ease-out, background 0.18s ease-out, box-shadow 0.18s ease-out, transform 0.12s ease-out;
      position: relative;
      overflow: hidden;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .scan-area-inner{
      pointer-events:none;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 10px;
      opacity: 0.92;
    }

    .scan-icon{ font-size: 2.4rem; }
    .scan-text{ font-size: 1.05rem; color: rgba(0,0,0,0.62); font-weight: 650; }
    .scan-hint{ font-size: 0.9rem; color: rgba(0,0,0,0.48); }

    .scan-area.state-neutral{
      border-style:dashed;
      border-color:var(--scan-border-neutral);
      background:var(--scan-bg-neutral);
      transform:translateY(0);
    }

    .scan-area.state-scanning{
      border-style:solid;
      border-color:var(--scan-border-scan);
      background:var(--scan-bg-scan);
      box-shadow:0 12px 26px rgba(0,0,0,0.16);
      transform:translateY(-2px);
    }

    .scan-area.state-correct{
      border-style:solid;
      border-color:var(--scan-border-good);
      background:var(--scan-bg-good);
      box-shadow:0 12px 30px rgba(76,175,80,0.35);
      transform:translateY(-2px);
    }

    .right.wrong{ animation: wiggle 240ms ease; }
    @keyframes wiggle{
      0%{ transform: translateX(0); }
      25%{ transform: translateX(-8px); }
      55%{ transform: translateX(7px); }
      100%{ transform: translateX(0); }
    }

    .scan-footnote{
      font-size: 13px;
      color: rgba(0,0,0,0.55);
      margin-top: 6px;
    }

    .startOverlay{
      position:fixed;
      inset:0;
      background: rgba(253,238,234,0.78);
      backdrop-filter: blur(2px);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index: 999;
      padding: 24px;
    }

    .startCard{
      width: min(560px, 92vw);
      background: #ffffff;
      border-radius: 24px;
      box-shadow: var(--shadow);
      padding: 22px 20px;
      text-align:center;
    }

    .startCard h1{
      margin: 0 0 10px 0;
      font-size: 28px;
      color: #4d4a48;
    }

    .startCard p{
      margin: 0 0 16px 0;
      color: rgba(77,74,72,0.82);
      font-size: 18px;
      line-height: 1.35;
    }

    .startBtn{
      appearance:none;
      border:none;
      background: var(--brand);
      color:#fff;
      font-weight: 800;
      padding: 14px 18px;
      border-radius: 18px;
      font-size: 18px;
      cursor:pointer;
      box-shadow: 0 14px 26px rgba(0,0,0,0.12);
    }
    .startBtn:active{ transform: scale(0.99); }

    @media (max-width: 900px){
      body{ flex-direction:column; }
      .right{
        border-left:none;
        border-top: 6px dashed rgba(245,180,152,0.85);
        min-width: unset;
      }
      .scan-area{ min-height: 46vh; }
    }
  </style>
</head>

<body>
  <section class="left" aria-label="Spel">
    <div class="topbar">
      <button class="homeBtn" id="homeBtn" aria-label="Naar het menu">
        <svg class="homeIcon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M3 10.6L12 3l9 7.6" stroke="#cf6d55" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M6.5 10.7V21h11V10.7" stroke="#cf6d55" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M9 21v-7h6v7" stroke="#cf6d55" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <div class="titlePill">pak het juiste cijfer</div>
    </div>

    <div class="content">
      <div class="gameCard" aria-label="Toverkaart">
        <button class="earBtn" id="earBtn" aria-label="Nog een keer luisteren"><span aria-hidden="true">ðŸ‘‚</span></button>

        <div class="stage" id="stage">
          <video id="fairyVid" muted playsinline preload="auto" aria-label="Toverfee video"></video>
          <img id="digitImg" alt="" />
          <img id="explosion" src="explosie.gif" alt="Explosie" />
        </div>
      </div>
    </div>
  </section>

  <section class="right" id="rightPane" aria-label="Scanvak">
    <div class="scanUI">
      <div class="miniTile" aria-hidden="true">
        <div>1</div><div>2</div><div>3</div><div>4</div>
      </div>

      <div class="scanTitle">Leg het houten cijfer in het vak.</div>
      <div class="scanSub">Alle puntjes in het vak.</div>

      <div class="scan-area state-neutral" id="scan-area" aria-label="Scanvak">
        <div class="scan-area-inner">
          <div class="scan-icon">ðŸ‘‰ðŸ”¢</div>
          <div class="scan-text" id="scan-text">Leg het cijfer hier</div>
          <div class="scan-hint" id="scan-hint">Blokje even stil laten liggen</div>
        </div>
      </div>

      <div class="scan-footnote">ðŸ“± Blokje stil laten liggen in het vak</div>
    </div>
  </section>

  <div class="startOverlay" id="startOverlay" role="dialog" aria-modal="true" aria-label="Start">
    <div class="startCard">
      <h1>Tik om te starten</h1>
      <p>Je hoort een cijfer, leg dat cijfer in het scanvak, met het oortje hoor je het nog eens.</p>
      <button class="startBtn" id="startBtn">Start</button>
    </div>
  </div>

  <script>
    /*
      Bestanden in dezelfde map:
      calibration.json
      marbotic0.png tot en met marbotic9.png
      explosie.gif
      toverfee.mp4
    */

    const DIGIT_WORDS_NL = ['nul','een','twee','drie','vier','vijf','zes','zeven','acht','negen'];
    const ASSET_DIGIT = (d) => `marbotic${d}.png`;
    const FAIRY_SRC = 'toverfee.mp4';

    const stage = document.getElementById('stage');
    const digitImg = document.getElementById('digitImg');
    const explosion = document.getElementById('explosion');
    const fairyVid = document.getElementById('fairyVid');

    const earBtn = document.getElementById('earBtn');
    const homeBtn = document.getElementById('homeBtn');

    const rightPane = document.getElementById('rightPane');
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');

    const scanArea = document.getElementById('scan-area');
    const scanText = document.getElementById('scan-text');
    const scanHint = document.getElementById('scan-hint');

    /* ================================
       MARBOTIC HERKENNINGSMODULE
       gebaseerd op jouw werkende Levels code
       ================================ */

    const DIGIT_ORDER = [0,1,2,3,4,5,6,7,8,9];

    let calibration = null;
    let classificationStats = null;
    let expectedTouchPoints = 3;

    function initCalibration(calibrationData) {
      if (!calibrationData || typeof calibrationData !== "object") {
        calibration = null;
        classificationStats = null;
        expectedTouchPoints = 3;
        return;
      }

      expectedTouchPoints = (typeof calibrationData.expectedTouchPoints === "number")
        ? calibrationData.expectedTouchPoints
        : 3;

      calibration = buildCalibrationFromData(calibrationData);
      recomputeClassificationStats();
    }

    function buildCalibrationFromData(data) {
      const obj = {};
      DIGIT_ORDER.forEach(function (d) {
        obj[String(d)] = { digit: d, samples: [] };
      });

      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        const entry = data[key];
        if (!entry || !Array.isArray(entry.samples)) return;

        entry.samples.forEach(function (s) {
          if (!s || !Array.isArray(s.points) || s.points.length !== 3) return;

          const pts = s.points.map(function (p) {
            return { x: Number(p.x), y: Number(p.y) };
          });

          const features = computeFeatures(pts);
          obj[key].samples.push({ points: pts, features: features });
        });
      });

      return obj;
    }

    function computeFeatures(points) {
      if (!points || points.length !== 3) {
        return {
          sides: [0, 0, 0],
          orientation: 0,
          cosAngle: 0,
          centroid: { x: 0, y: 0 },
          yNorm: [0, 0, 0],
          xPattern: [0, 0, 0],
          aspect: 0,
          vector: [0, 0, 0]
        };
      }

      const p0 = points[0];
      const p1 = points[1];
      const p2 = points[2];

      const centroidRaw = {
        x: (p0.x + p1.x + p2.x) / 3,
        y: (p0.y + p1.y + p2.y) / 3
      };

      const isoPoints = [p0, p1, p2].map(function (p) {
        const dx = p.x - centroidRaw.x;
        const dy = p.y - centroidRaw.y;
        return { x: dx, y: dy };
      });

      let maxDist = 0;
      for (let i = 0; i < isoPoints.length; i++) {
        const q = isoPoints[i];
        const d = Math.sqrt(q.x * q.x + q.y * q.y);
        if (d > maxDist) maxDist = d;
      }
      if (maxDist < 1e-6) maxDist = 1;

      for (let i = 0; i < isoPoints.length; i++) {
        isoPoints[i].x /= maxDist;
        isoPoints[i].y /= maxDist;
      }

      function dist(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.sqrt(dx * dx + dy * dy);
      }

      const L01 = dist(isoPoints[0], isoPoints[1]);
      const L12 = dist(isoPoints[1], isoPoints[2]);
      const L20 = dist(isoPoints[2], isoPoints[0]);

      const sides = [
        { len: L01, i: 0, j: 1 },
        { len: L12, i: 1, j: 2 },
        { len: L20, i: 2, j: 0 }
      ];
      const maxSideLen = Math.max(L01, L12, L20) || 1;
      const sidesNormSorted = sides
        .slice()
        .sort(function (a, b) { return a.len - b.len; })
        .map(function (s) { return s.len / maxSideLen; });

      const largest = sides
        .slice()
        .sort(function (a, b) { return a.len - b.len; })[2];

      const A = isoPoints[largest.i];
      const B = isoPoints[largest.j];
      const CIndex = 3 - largest.i - largest.j;
      const C = isoPoints[CIndex];

      function orientationVal(a, b, c) {
        const value =
          (b.x - a.x) * (c.y - a.y) -
          (b.y - a.y) * (c.x - a.x);
        if (value > 0) return 1;
        if (value < 0) return -1;
        return 0;
      }

      const orientation = orientationVal(A, B, C);

      const AC = dist(A, C);
      const BC = dist(B, C);
      const AB = largest.len;
      const denom = 2 * AC * BC;

      let cosAngle = 0;
      if (denom > 1e-6) {
        cosAngle = (AC * AC + BC * BC - AB * AB) / denom;
      }

      let minX = Math.min(p0.x, p1.x, p2.x);
      let maxX = Math.max(p0.x, p1.x, p2.x);
      let minY = Math.min(p0.y, p1.y, p2.y);
      let maxY = Math.max(p0.y, p1.y, p2.y);
      let width = maxX - minX;
      let height = maxY - minY;
      if (width < 1e-6) width = 1;
      if (height < 1e-6) height = 1;

      const yNormVals = [p0, p1, p2]
        .map(function (p) { return (p.y - minY) / height; })
        .sort(function (a, b) { return a - b; });

      const pointsWithIndex = [
        { p: p0, idx: 0 },
        { p: p1, idx: 1 },
        { p: p2, idx: 2 }
      ].sort(function (a, b) { return a.p.y - b.p.y; });

      const xPattern = pointsWithIndex.map(function (item) {
        return (item.p.x - minX) / width;
      });

      const aspect = height / (width + height);

      const centroidBox = {
        x: (centroidRaw.x - minX) / width,
        y: (centroidRaw.y - minY) / height
      };

      const vector = buildFeatureVector({
        sides: sidesNormSorted,
        orientation: orientation,
        cosAngle: cosAngle,
        centroid: centroidBox,
        yNorm: yNormVals,
        xPattern: xPattern,
        aspect: aspect
      });

      return {
        sides: sidesNormSorted,
        orientation: orientation,
        cosAngle: cosAngle,
        centroid: centroidBox,
        yNorm: yNormVals,
        xPattern: xPattern,
        aspect: aspect,
        vector: vector
      };
    }

    function buildFeatureVector(f) {
      const wSides = 3.0;
      const wCos = 4.0;
      const wOrient = 2.0;
      const wY = 3.0;
      const wX = 2.0;
      const wAspect = 2.0;

      const v = [];
      v.push(f.sides[0] * wSides);
      v.push(f.sides[1] * wSides);
      v.push(f.sides[2] * wSides);

      v.push(f.cosAngle * wCos);
      v.push(f.orientation * wOrient);

      v.push(f.yNorm[0] * wY);
      v.push(f.yNorm[1] * wY);
      v.push(f.yNorm[2] * wY);

      v.push(f.xPattern[0] * wX);
      v.push(f.xPattern[1] * wX);
      v.push(f.xPattern[2] * wX);

      v.push(f.aspect * wAspect);
      return v;
    }

    function vectorDistance(a, b) {
      if (!a || !b || a.length !== b.length) return Infinity;
      let sum = 0;
      for (let i = 0; i < a.length; i++) {
        const diff = a[i] - b[i];
        sum += diff * diff;
      }
      return Math.sqrt(sum);
    }

    function recomputeClassificationStats() {
      if (!calibration) {
        classificationStats = { thresholdBase: 0.8, thresholdUnknown: 1.5 };
        return;
      }

      const allSamples = [];
      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        if (!calibration[key]) return;
        const samples = calibration[key].samples || [];
        samples.forEach(function (s) {
          allSamples.push({ digit: d, features: s.features });
        });
      });

      if (allSamples.length < 2) {
        classificationStats = { thresholdBase: 0.6, thresholdUnknown: 1.0 };
        return;
      }

      const sameMinDistances = [];
      const betweenMinDistances = [];

      for (let i = 0; i < allSamples.length; i++) {
        const a = allSamples[i];
        const vecA = a.features.vector;
        let minSame = Infinity;
        let minOther = Infinity;

        for (let j = 0; j < allSamples.length; j++) {
          if (i === j) continue;
          const b = allSamples[j];
          const vecB = b.features.vector;
          const dist = vectorDistance(vecA, vecB);

          if (a.digit === b.digit) {
            if (dist < minSame) minSame = dist;
          } else {
            if (dist < minOther) minOther = dist;
          }
        }

        if (minSame < Infinity) sameMinDistances.push(minSame);
        if (minOther < Infinity) betweenMinDistances.push(minOther);
      }

      if (sameMinDistances.length === 0 || betweenMinDistances.length === 0) {
        classificationStats = { thresholdBase: 0.7, thresholdUnknown: 1.2 };
        return;
      }

      const maxSame = Math.max.apply(null, sameMinDistances);
      const minBetween = Math.min.apply(null, betweenMinDistances);

      let thresholdBase;
      if (minBetween > maxSame) thresholdBase = (maxSame + minBetween) / 2;
      else thresholdBase = maxSame * 1.3;

      const thresholdUnknown = thresholdBase * 1.5;

      classificationStats = {
        thresholdBase: thresholdBase,
        thresholdUnknown: thresholdUnknown
      };
    }

    function classifyMeasurement(features) {
      const vec = features.vector;
      if (!vec || !calibration) return { digit: null, isUnknown: true };

      let bestDigit = null;
      let bestDist = Infinity;

      DIGIT_ORDER.forEach(function (d) {
        const entry = calibration[String(d)];
        if (!entry) return;
        const samples = entry.samples || [];
        for (let i = 0; i < samples.length; i++) {
          const dist = vectorDistance(vec, samples[i].features.vector);
          if (dist < bestDist) { bestDist = dist; bestDigit = d; }
        }
      });

      if (bestDigit === null || bestDist === Infinity) return { digit: null, isUnknown: true };

      const stats = classificationStats || { thresholdBase: 0.8, thresholdUnknown: 1.5 };
      if (bestDist > stats.thresholdUnknown) return { digit: null, isUnknown: true };
      if (bestDist > stats.thresholdBase) return { digit: null, isUnknown: true };

      return { digit: bestDigit, isUnknown: false };
    }

    function recognizeDigit(points) {
      if (!calibration || !classificationStats) return null;
      if (!Array.isArray(points) || points.length !== expectedTouchPoints) return null;

      const features = computeFeatures(points);
      const classification = classifyMeasurement(features);

      if (!classification || classification.isUnknown || classification.digit == null) return null;
      return classification.digit;
    }

    /* ================================
       SPELLOGICA
       ================================ */

    let started = false;
    let locked = false;
    let targetDigit = 0;

    let currentPoints = [];
    let hasResultForCurrentTouches = false;

    function setScanState(state){
      scanArea.classList.remove('state-neutral','state-scanning','state-correct');
      if (state === 'scanning') scanArea.classList.add('state-scanning');
      else if (state === 'correct') scanArea.classList.add('state-correct');
      else scanArea.classList.add('state-neutral');

      if (state === 'neutral'){
        scanText.textContent = 'Leg het cijfer hier';
        scanHint.textContent = 'Blokje even stil laten liggen';
      } else if (state === 'scanning'){
        scanText.textContent = 'Even stil houden';
        scanHint.textContent = 'We lezen de puntjes';
      } else if (state === 'correct'){
        scanText.textContent = 'Goed gedaan';
        scanHint.textContent = '';
      }
    }

    function wrongFeedback(){
      rightPane.classList.remove('wrong');
      void rightPane.offsetHeight;
      rightPane.classList.add('wrong');
    }

    function speakDigit(digit){
      const word = DIGIT_WORDS_NL[digit] ?? String(digit);
      if (!('speechSynthesis' in window)) return;
      try{
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(word);
        u.lang = 'nl-NL';
        u.rate = 0.92;
        u.pitch = 1.05;
        window.speechSynthesis.speak(u);
      }catch(e){}
    }

    function chooseNextDigit(){
      const prev = targetDigit;
      let next = Math.floor(Math.random() * 10);
      if (next === prev) next = (next + 1) % 10;
      targetDigit = next;
    }

    function restartGif(img){
      const base = img.dataset.baseSrc || img.getAttribute('src');
      img.dataset.baseSrc = base;
      const bust = (base.includes('?') ? '&' : '?') + 't=' + Date.now();
      img.setAttribute('src', base + bust);
    }

    function getVarSeconds(name, fallbackSeconds){
      const raw = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      if (!raw) return fallbackSeconds;
      if (raw.endsWith('ms')) return parseFloat(raw) / 1000;
      if (raw.endsWith('s')) return parseFloat(raw);
      const n = parseFloat(raw);
      return Number.isFinite(n) ? n : fallbackSeconds;
    }

    function getVarMillis(name, fallbackMs){
      const raw = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      if (!raw) return fallbackMs;
      if (raw.endsWith('ms')) return parseFloat(raw);
      if (raw.endsWith('s')) return parseFloat(raw) * 1000;
      const n = parseFloat(raw);
      return Number.isFinite(n) ? n : fallbackMs;
    }

    function fadeOutAndHide(img, delaySeconds, fadeMs){
      window.setTimeout(() => {
        img.style.animation = 'none';
        void img.offsetHeight;
        img.style.transition = `opacity ${fadeMs}ms ease`;
        void img.offsetHeight;
        img.style.opacity = '0';
        window.setTimeout(() => { img.style.transition = ''; }, Math.max(0, fadeMs + 80));
      }, Math.max(0, delaySeconds * 1000));
    }

    function freezeOnLastFrame(video){
      const d = Number.isFinite(video.duration) ? video.duration : 0;
      const t = Math.max(0, d - 0.04);
      video.addEventListener('seeked', () => video.pause(), { once:true });
      try{ video.currentTime = t; }catch(e){ video.pause(); }
    }

    function clearCard(){
      stage.classList.remove('play');
      digitImg.style.opacity = '0';
      digitImg.removeAttribute('src');
      digitImg.alt = '';
      explosion.style.opacity = '0';
      fairyVid.style.opacity = '0';
    }

    function playSuccessAnimation(digit){
      clearCard();

      digitImg.src = ASSET_DIGIT(digit);
      digitImg.alt = String(digit);

      restartGif(explosion);

      // Toverfee direct spelen, video is al â€œunlockedâ€ bij Start
      fairyVid.onended = () => freezeOnLastFrame(fairyVid);
      try { fairyVid.currentTime = 0; } catch(e) {}
      fairyVid.play().catch(() => {});

      void stage.offsetHeight;
      stage.classList.add('play');

      const hideAfter = getVarSeconds('--explosion-hide-after', 2.2);
      fadeOutAndHide(explosion, hideAfter, getVarMillis('--explosion-fadeout', 220));
    }

    function nextRound(){
      locked = false;
      clearCard();
      setScanState('neutral');
      chooseNextDigit();
      speakDigit(targetDigit);
    }

    function handleRecognitionResult(recognizedDigit){
      if (recognizedDigit == null) return;
      if (!started || locked) return;

      if (recognizedDigit === targetDigit){
        locked = true;
        setScanState('correct');
        playSuccessAnimation(recognizedDigit);
        window.setTimeout(() => { nextRound(); }, 1800);
      } else {
        wrongFeedback();
      }
    }

    function getPointsFromTouches(touchList) {
      const rect = scanArea.getBoundingClientRect();
      const points = [];
      for (let i = 0; i < touchList.length; i++) {
        const t = touchList[i];
        const x = t.clientX;
        const y = t.clientY;
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          points.push({ x: x, y: y });
        }
      }
      return points;
    }

    function handleTouchEvent(e){
      if (!calibration || !classificationStats) return;

      const touches = e.touches || [];
      currentPoints = getPointsFromTouches(touches);

      if (currentPoints.length === 0){
        hasResultForCurrentTouches = false;
        setScanState('neutral');
        return;
      }

      if (currentPoints.length !== expectedTouchPoints){
        hasResultForCurrentTouches = false;
        setScanState('scanning');
        return;
      }

      setScanState('scanning');

      if (!hasResultForCurrentTouches && !locked){
        const digit = recognizeDigit(currentPoints);
        if (digit !== null && typeof digit === "number"){
          hasResultForCurrentTouches = true;
          handleRecognitionResult(digit);
        }
      }
    }

    ['touchstart','touchmove','touchend','touchcancel'].forEach(type => {
      scanArea.addEventListener(type, handleTouchEvent, { passive: true });
    });

    function unlockFairyVideo(){
      fairyVid.muted = true;
      fairyVid.playsInline = true;
      fairyVid.loop = false;
      fairyVid.controls = false;
      fairyVid.src = FAIRY_SRC;
      fairyVid.load();

      const p = fairyVid.play();
      if (p && typeof p.then === "function"){
        p.then(() => {
          fairyVid.pause();
          try { fairyVid.currentTime = 0; } catch(e) {}
        }).catch(() => {});
      }
    }

    function startGame(){
      if (started) return;
      started = true;
      startOverlay.style.display = 'none';
      unlockFairyVideo();
      nextRound();
    }

    earBtn.addEventListener('click', () => {
      if (!started) startGame();
      else speakDigit(targetDigit);
    });

    startBtn.addEventListener('click', startGame);
    startOverlay.addEventListener('click', (e) => {
      if (e.target === startOverlay) startGame();
    });

    homeBtn.addEventListener('click', () => {
      try { window.location.href = 'index.html'; } catch (e) {}
    });

    window.addEventListener('load', () => {
      clearCard();
      setScanState('neutral');

      fetch('calibration.json', { cache: 'no-store' })
        .then(r => r.json())
        .then(data => initCalibration(data))
        .catch(() => {
          // geen melding in beeld, net als je Levels code
        });
    });
  </script>
</body>
</html>
