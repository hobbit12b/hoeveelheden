<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>Marbotic - TG07 Luister & Leg</title>

  <!-- Anti-zoom (belangrijk op iPad) -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />

  <style>
    :root {
      --bg-top: #f4f1ff;
      --bg-bottom: #fef6e9;
      --card-bg: #ffffff;
      --card-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
      --accent-soft: #ffe0b2;
      --accent-strong: #ff8a65;

      --scan-border-neutral: rgba(255, 255, 255, 0.8);
      --scan-border-scan: rgba(255, 255, 255, 0.9);
      --scan-border-good: #4caf50;
      --scan-border-bad: #e53935;

      --scan-bg-neutral: rgba(255, 255, 255, 0.12);
      --scan-bg-scan: rgba(255, 255, 255, 0.22);
      --scan-bg-good: rgba(76, 175, 80, 0.18);
      --scan-bg-bad: rgba(229, 57, 53, 0.18);

      --text-main: #333333;
      --text-soft: #666666;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { margin: 0; padding: 0; height: 100%; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom));
      color: var(--text-main);
      display: flex;
      justify-content: center;
      align-items: stretch;
      touch-action: none; /* we beheren touch zelf */
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      overflow: hidden;
    }

    .game {
      width: 100%;
      max-width: 900px;
      min-height: 100vh;
      padding: clamp(12px, 3vh, 24px);
      padding-top: calc(clamp(12px, 3vh, 24px) + env(safe-area-inset-top));
      padding-bottom: calc(clamp(12px, 3vh, 24px) + env(safe-area-inset-bottom));
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    header {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .home-btn {
      width: 54px;
      height: 54px;
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.75);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.6rem;
      text-decoration: none;
      color: inherit;
      flex: 0 0 auto;
    }
    .home-btn:active { transform: scale(0.98); }

    .title-badge {
      flex: 1 1 auto;
      background: rgba(255, 255, 255, 0.75);
      border-radius: 999px;
      padding: 10px 14px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      min-height: 54px;
      cursor: pointer;
      user-select: none;
    }
    .title-icon { font-size: 1.35rem; }
    .title-text { font-size: 1rem; font-weight: 800; letter-spacing: 0.02em; white-space: nowrap; }

    .level-chip {
      width: 54px;
      height: 54px;
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.75);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3rem;
      flex: 0 0 auto;
    }

    /* ===== Bovenstuk (klein) ===== */
    .game-main {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .stage {
      width: min(86vw, 520px);
      height: min(24vh, 200px); /* kleiner dan TG08, boven scanvlak */
      border-radius: 30px;
      box-shadow: var(--card-shadow);
      background: rgba(255, 255, 255, 0.75);
      position: relative;
      overflow: hidden;
      border: 4px solid rgba(255, 255, 255, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .reveal {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 14px;
      padding: 12px;
    }

    .reveal-digit {
      height: 100%;
      aspect-ratio: 1 / 1;
      max-height: 150px;
      border-radius: 22px;
      background: #fff;
      box-shadow: 0 10px 22px rgba(0,0,0,0.10);
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain;
      border: 4px solid transparent;
      flex: 0 0 auto;
    }

    .reveal-mark {
      font-size: min(10vw, 72px);
      line-height: 1;
      opacity: 0.96;
      flex: 0 0 auto;
    }

    .curtains {
      position: absolute;
      inset: 0;
      display: flex;
      pointer-events: none;
      z-index: 5;
    }

    .curtain {
      width: 50%;
      height: 100%;
      background-size: cover;
      background-repeat: no-repeat;
      will-change: transform;
      transition: transform 0.55s cubic-bezier(.2,.8,.2,1);
      filter: saturate(1.05) contrast(1.05);
      background-image: url('gordijnen_still.png');
    }
    .curtains.anim .curtain { background-image: url('gordijnen.gif'); }

    .curtain.left  { background-position: left  center; transform: translateX(0); }
    .curtain.right { background-position: right center; transform: translateX(0); }
    .curtains.open .curtain.left  { transform: translateX(-102%); }
    .curtains.open .curtain.right { transform: translateX(102%); }

    /* na open: gordijnen echt weg (gif niet zichtbaar) */
    .curtains.hidden { display: none; }

    .sparkle {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: min(16vw, 96px);
      opacity: 0;
      transform: scale(0.92);
      transition: opacity .22s ease-out, transform .22s ease-out;
      pointer-events: none;
      z-index: 6;
    }
    .sparkle.show { opacity: 1; transform: scale(1); }

    .hint-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      color: var(--text-soft);
      font-weight: 800;
      background: rgba(255, 255, 255, 0.55);
      border-radius: 999px;
      padding: 10px 14px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      max-width: min(86vw, 520px);
    }
    .hint-ico { font-size: 1.35rem; }

    .progress {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.55);
      border-radius: 999px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      flex-wrap: wrap;
      max-width: min(86vw, 520px);
    }
    .pip {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.14);
      opacity: 0.75;
      transition: transform .16s ease-out, opacity .16s ease-out, background .16s ease-out;
    }
    .pip.on {
      opacity: 1;
      transform: scale(1.12);
      background: rgba(0, 0, 0, 0.30);
    }

    /* ===== Scanstuk (groot zoals TG08) ===== */
    .game-footer {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      margin-top: 2px;
    }

    .scan-area {
      border-radius: 28px;
      border-width: 4px;
      border-style: dashed;
      border-color: var(--scan-border-neutral);
      background: var(--scan-bg-neutral);

      flex: 1 1 auto;
      min-height: 60vh; /* KEY: groot als TG08 */

      display: flex;
      align-items: center;
      justify-content: center;

      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.12);
      transition: border-color 0.18s ease-out, background 0.18s ease-out, box-shadow 0.18s ease-out, transform 0.12s ease-out;
      position: relative;
      overflow: hidden;
    }

    .scan-area-inner {
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      pointer-events: none;
    }

    .scan-icon { font-size: 2.4rem; animation: scanPulse 2s ease-in-out infinite; }
    @keyframes scanPulse { 0%{transform:scale(1);opacity:.9} 100%{transform:scale(1.08);opacity:1} }

    .scan-text { font-size: 1.05rem; color: var(--text-soft); }
    .scan-hint { font-size: 0.85rem; color: rgba(0,0,0,0.48); }

    .scan-area.state-neutral { border-style: dashed; border-color: var(--scan-border-neutral); background: var(--scan-bg-neutral); transform: translateY(0); }
    .scan-area.state-scanning { border-style: solid; border-color: var(--scan-border-scan); background: var(--scan-bg-scan); box-shadow: 0 12px 26px rgba(0,0,0,0.16); transform: translateY(-2px); }
    .scan-area.state-correct { border-style: solid; border-color: var(--scan-border-good); background: var(--scan-bg-good); box-shadow: 0 12px 30px rgba(76,175,80,0.35); transform: translateY(-2px); }
    .scan-area.state-wrong { border-style: solid; border-color: var(--scan-border-bad); background: var(--scan-bg-bad); box-shadow: 0 12px 30px rgba(229,57,53,0.35); transform: translateY(-2px); }

    @media (max-width: 600px) {
      .home-btn, .level-chip { width: 50px; height: 50px; border-radius: 16px; }
      .title-text { font-size: 0.95rem; }
      .stage { border-radius: 26px; height: min(22vh, 180px); }
      .reveal-digit { border-radius: 20px; }
      .pip { width: 13px; height: 13px; }
    }
  </style>
</head>

<body>
  <div class="game" id="game" data-level="1">
    <header>
      <a class="home-btn" href="index.html" aria-label="Terug naar start">üè†</a>

      <div class="title-badge" id="title-badge" role="button" aria-label="Luister nog een keer">
        <span class="title-icon">üîä</span>
        <span class="title-text">Luister & leg</span>
      </div>

      <div class="level-chip" id="level-chip" aria-label="Level">üå±</div>
    </header>

    <main class="game-main">
      <div class="stage" aria-label="Gordijn">
        <div class="reveal" aria-hidden="true">
          <div class="reveal-digit" id="reveal-digit"></div>
          <div class="reveal-mark" id="reveal-mark">üé≠</div>
        </div>

        <div class="curtains" id="curtains" aria-hidden="true">
          <div class="curtain left"></div>
          <div class="curtain right"></div>
        </div>

        <div class="sparkle" id="sparkle">‚≠ê</div>
      </div>

      <div class="hint-row" aria-label="Hint">
        <span class="hint-ico">üëÇ</span>
        <span>Tik op üîä en leg het cijfer</span>
      </div>

      <div class="progress" id="progress" aria-label="Voortgang"></div>
    </main>

    <footer class="game-footer">
      <div class="scan-area state-neutral" id="scan-area" aria-label="Scanvak">
        <div class="scan-area-inner">
          <div class="scan-icon">üî¢</div>
          <div class="scan-text">Leg het houten cijfer in het vak</div>
          <div class="scan-hint">Alle puntjes in het vak</div>
        </div>
      </div>
    </footer>
  </div>

  <script>
    /* =====================================================
       Anti-zoom/gesture (iPad): voorkom dubbele tik zoom & pinch
       ===================================================== */
    document.addEventListener('gesturestart', function(e){ e.preventDefault(); }, { passive:false });
    document.addEventListener('gesturechange', function(e){ e.preventDefault(); }, { passive:false });
    document.addEventListener('gestureend', function(e){ e.preventDefault(); }, { passive:false });

    let __lastTouchEnd = 0;
    document.addEventListener('touchend', function(e){
      const now = Date.now();
      if (now - __lastTouchEnd <= 300) e.preventDefault();
      __lastTouchEnd = now;
    }, { passive:false });

    /* ================================
       MARBOTIC HERKENNINGSMODULE
       (logica ongewijzigd)
       ================================ */

    const DIGIT_ORDER = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

    let calibration = null;
    let classificationStats = null;
    let expectedTouchPoints = 3;

    function initCalibration(calibrationData) {
      if (!calibrationData || typeof calibrationData !== "object") {
        calibration = null;
        classificationStats = null;
        expectedTouchPoints = 3;
        return;
      }

      if (typeof calibrationData.expectedTouchPoints === "number") {
        expectedTouchPoints = calibrationData.expectedTouchPoints;
      } else {
        expectedTouchPoints = 3;
      }

      calibration = buildCalibrationFromData(calibrationData);
      recomputeClassificationStats();
    }

    function buildCalibrationFromData(data) {
      const obj = {};
      DIGIT_ORDER.forEach(function (d) {
        obj[String(d)] = { digit: d, samples: [] };
      });

      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        const entry = data[key];
        if (!entry || !Array.isArray(entry.samples)) return;

        entry.samples.forEach(function (s) {
          if (!s || !Array.isArray(s.points) || s.points.length !== 3) return;

          const pts = s.points.map(function (p) {
            return { x: Number(p.x), y: Number(p.y) };
          });

          const features = computeFeatures(pts);
          obj[key].samples.push({ points: pts, features: features });
        });
      });

      return obj;
    }

    function computeFeatures(points) {
      if (!points || points.length !== 3) {
        return {
          sides: [0, 0, 0],
          orientation: 0,
          cosAngle: 0,
          centroid: { x: 0, y: 0 },
          yNorm: [0, 0, 0],
          xPattern: [0, 0, 0],
          aspect: 0,
          vector: [0, 0, 0]
        };
      }

      const p0 = points[0];
      const p1 = points[1];
      const p2 = points[2];

      const centroidRaw = {
        x: (p0.x + p1.x + p2.x) / 3,
        y: (p0.y + p1.y + p2.y) / 3
      };

      const isoPoints = [p0, p1, p2].map(function (p) {
        const dx = p.x - centroidRaw.x;
        const dy = p.y - centroidRaw.y;
        return { x: dx, y: dy };
      });

      let maxDist = 0;
      for (let i = 0; i < isoPoints.length; i++) {
        const q = isoPoints[i];
        const d = Math.sqrt(q.x * q.x + q.y * q.y);
        if (d > maxDist) maxDist = d;
      }
      if (maxDist < 1e-6) maxDist = 1;

      for (let i = 0; i < isoPoints.length; i++) {
        isoPoints[i].x /= maxDist;
        isoPoints[i].y /= maxDist;
      }

      function dist(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.sqrt(dx * dx + dy * dy);
      }

      const L01 = dist(isoPoints[0], isoPoints[1]);
      const L12 = dist(isoPoints[1], isoPoints[2]);
      const L20 = dist(isoPoints[2], isoPoints[0]);

      const sides = [
        { len: L01, i: 0, j: 1 },
        { len: L12, i: 1, j: 2 },
        { len: L20, i: 2, j: 0 }
      ];
      const maxSideLen = Math.max(L01, L12, L20) || 1;
      const sidesNormSorted = sides
        .slice()
        .sort(function (a, b) { return a.len - b.len; })
        .map(function (s) { return s.len / maxSideLen; });

      const largest = sides
        .slice()
        .sort(function (a, b) { return a.len - b.len; })[2];

      const A = isoPoints[largest.i];
      const B = isoPoints[largest.j];
      const CIndex = 3 - largest.i - largest.j;
      const C = isoPoints[CIndex];

      function orientationVal(a, b, c) {
        const value =
          (b.x - a.x) * (c.y - a.y) -
          (b.y - a.y) * (c.x - a.x);
        if (value > 0) return 1;
        if (value < 0) return -1;
        return 0;
      }

      const orientation = orientationVal(A, B, C);

      const AC = dist(A, C);
      const BC = dist(B, C);
      const AB = largest.len;
      const AC2 = AC * AC;
      const BC2 = BC * BC;
      const AB2 = AB * AB;
      let cosAngle = 0;
      const denom = 2 * AC * BC;
      if (denom > 1e-6) {
        cosAngle = (AC2 + BC2 - AB2) / denom;
      }

      let minX = Math.min(p0.x, p1.x, p2.x);
      let maxX = Math.max(p0.x, p1.x, p2.x);
      let minY = Math.min(p0.y, p1.y, p2.y);
      let maxY = Math.max(p0.y, p1.y, p2.y);
      let width = maxX - minX;
      let height = maxY - minY;
      if (width < 1e-6) width = 1;
      if (height < 1e-6) height = 1;

      const yNormVals = [p0, p1, p2]
        .map(function (p) { return (p.y - minY) / height; })
        .sort(function (a, b) { return a - b; });

      const pointsWithIndex = [
        { p: p0, idx: 0 },
        { p: p1, idx: 1 },
        { p: p2, idx: 2 }
      ].sort(function (a, b) { return a.p.y - b.p.y; });

      const xPattern = pointsWithIndex.map(function (item) {
        return (item.p.x - minX) / width;
      });

      const aspect = height / (width + height);

      const centroidBox = {
        x: (centroidRaw.x - minX) / width,
        y: (centroidRaw.y - minY) / height
      };

      const vector = buildFeatureVector({
        sides: sidesNormSorted,
        orientation: orientation,
        cosAngle: cosAngle,
        centroid: centroidBox,
        yNorm: yNormVals,
        xPattern: xPattern,
        aspect: aspect
      });

      return {
        sides: sidesNormSorted,
        orientation: orientation,
        cosAngle: cosAngle,
        centroid: centroidBox,
        yNorm: yNormVals,
        xPattern: xPattern,
        aspect: aspect,
        vector: vector
      };
    }

    function buildFeatureVector(f) {
      const wSides = 3.0;
      const wCos = 4.0;
      const wOrient = 2.0;
      const wY = 3.0;
      const wX = 2.0;
      const wAspect = 2.0;

      const v = [];
      v.push(f.sides[0] * wSides);
      v.push(f.sides[1] * wSides);
      v.push(f.sides[2] * wSides);

      v.push(f.cosAngle * wCos);
      v.push(f.orientation * wOrient);

      v.push(f.yNorm[0] * wY);
      v.push(f.yNorm[1] * wY);
      v.push(f.yNorm[2] * wY);

      v.push(f.xPattern[0] * wX);
      v.push(f.xPattern[1] * wX);
      v.push(f.xPattern[2] * wX);

      v.push(f.aspect * wAspect);

      return v;
    }

    function vectorDistance(a, b) {
      if (!a || !b || a.length !== b.length) return Infinity;
      let sum = 0;
      for (let i = 0; i < a.length; i++) {
        const diff = a[i] - b[i];
        sum += diff * diff;
      }
      return Math.sqrt(sum);
    }

    function recomputeClassificationStats() {
      if (!calibration) {
        classificationStats = { thresholdBase: 0.8, thresholdUnknown: 1.5 };
        return;
      }

      const allSamples = [];
      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        if (!calibration[key]) return;
        const samples = calibration[key].samples || [];
        samples.forEach(function (s) {
          allSamples.push({ digit: d, features: s.features });
        });
      });

      if (allSamples.length < 2) {
        classificationStats = { thresholdBase: 0.6, thresholdUnknown: 1.0 };
        return;
      }

      const sameMinDistances = [];
      const betweenMinDistances = [];

      for (let i = 0; i < allSamples.length; i++) {
        const a = allSamples[i];
        const vecA = a.features.vector;
        let minSame = Infinity;
        let minOther = Infinity;

        for (let j = 0; j < allSamples.length; j++) {
          if (i === j) continue;
          const b = allSamples[j];
          const vecB = b.features.vector;
          const dist = vectorDistance(vecA, vecB);

          if (a.digit === b.digit) {
            if (dist < minSame) minSame = dist;
          } else {
            if (dist < minOther) minOther = dist;
          }
        }

        if (minSame < Infinity) sameMinDistances.push(minSame);
        if (minOther < Infinity) betweenMinDistances.push(minOther);
      }

      if (sameMinDistances.length === 0 || betweenMinDistances.length === 0) {
        classificationStats = { thresholdBase: 0.7, thresholdUnknown: 1.2 };
        return;
      }

      const maxSame = Math.max.apply(null, sameMinDistances);
      const minBetween = Math.min.apply(null, betweenMinDistances);

      let thresholdBase;
      if (minBetween > maxSame) thresholdBase = (maxSame + minBetween) / 2;
      else thresholdBase = maxSame * 1.3;

      const thresholdUnknown = thresholdBase * 1.5;

      classificationStats = {
        thresholdBase: thresholdBase,
        thresholdUnknown: thresholdUnknown,
        maxSame: maxSame,
        minBetween: minBetween
      };
    }

    function classifyMeasurement(features) {
      const vec = features.vector;
      if (!vec || !calibration) {
        return { digit: null, bestDist: null, certainty: "onbekend", isUnknown: true, topMatches: [] };
      }

      const bestPerDigit = {};
      DIGIT_ORDER.forEach(function (d) { bestPerDigit[d] = Infinity; });

      let bestDigit = null;
      let bestDist = Infinity;

      DIGIT_ORDER.forEach(function (d) {
        const key = String(d);
        const entry = calibration[key];
        if (!entry) return;
        const samples = entry.samples || [];
        for (let i = 0; i < samples.length; i++) {
          const sampleVec = samples[i].features.vector;
          const dist = vectorDistance(vec, sampleVec);
          if (dist < bestPerDigit[d]) bestPerDigit[d] = dist;
          if (dist < bestDist) { bestDist = dist; bestDigit = d; }
        }
      });

      const perDigitArray = [];
      DIGIT_ORDER.forEach(function (d) {
        const val = bestPerDigit[d];
        if (val < Infinity) perDigitArray.push({ digit: d, distance: val });
      });
      perDigitArray.sort(function (a, b) { return a.distance - b.distance; });
      const topMatches = perDigitArray.slice(0, 3);

      if (bestDigit === null || bestDist === Infinity) {
        return { digit: null, bestDist: null, certainty: "onbekend", isUnknown: true, topMatches: topMatches };
      }

      let stats = classificationStats || { thresholdBase: 0.8, thresholdUnknown: 1.5 };
      const base = stats.thresholdBase;
      const unknownThresh = stats.thresholdUnknown;

      let isUnknown = false;
      let certainty = "zeker";

      if (bestDist > unknownThresh) isUnknown = true;
      else if (bestDist > base) certainty = "twijfelachtig";

      if (!isUnknown && topMatches.length > 1) {
        const second = topMatches[1].distance;
        if (second > 0) {
          const ratio = bestDist / second;
          if (ratio > 0.9 && certainty === "zeker") certainty = "twijfelachtig";
        }
      }

      return {
        digit: isUnknown ? null : bestDigit,
        bestDist: bestDist,
        certainty: certainty,
        isUnknown: isUnknown,
        topMatches: topMatches
      };
    }

    function recognizeDigit(points) {
      if (!calibration || !classificationStats) return null;
      if (!Array.isArray(points) || points.length !== expectedTouchPoints) return null;

      const features = computeFeatures(points);
      const classification = classifyMeasurement(features);

      if (!classification || classification.isUnknown || classification.digit == null) return null;
      return classification.digit;
    }

    /* ================================
       TG07: LUISTER & LEG (gordijn + herhaling)
       ================================ */

    const DIGIT_IMAGE_PREFIX = "marbotic";
    const DIGIT_IMAGE_SUFFIX = ".png";

    const NUMBER_WORDS = {
      0:"nul", 1:"√©√©n", 2:"twee", 3:"drie", 4:"vier",
      5:"vijf", 6:"zes", 7:"zeven", 8:"acht", 9:"negen"
    };
    function wordFor(d){ return NUMBER_WORDS[d] || String(d); }

    // WebAudio (piepjes) ‚Äì wordt ‚Äúunlocked‚Äù bij eerste aanraking
    let audioCtx = null;
    function ensureAudio(){
      if (!audioCtx){
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) audioCtx = new AC();
      }
      if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
    }
    function playTone(freq, duration){
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.frequency.value = freq;
      osc.type = "sine";
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.22, now + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      osc.start(now);
      osc.stop(now + duration + 0.05);
    }
    function sfxGood(){ playTone(880, 0.14); setTimeout(function(){ playTone(1175, 0.16); }, 120); }
    function sfxBad(){ playTone(220, 0.20); }

    // SpeechSynthesis queue (niet afkappen tijdens feedback)
    let preferredVoice = null;
    let speechBusy = false;

    function pickDutchVoice(){
      if (!("speechSynthesis" in window)) return null;
      const voices = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : [];
      if (!voices || voices.length === 0) return null;
      for (let i=0;i<voices.length;i++){
        const v = voices[i];
        if ((v.lang || "").toLowerCase().startsWith("nl")) return v;
      }
      return null;
    }
    function ensureVoice(){
      if (!("speechSynthesis" in window)) return;
      if (!preferredVoice) preferredVoice = pickDutchVoice();
    }
    if ("speechSynthesis" in window){
      window.speechSynthesis.onvoiceschanged = function(){ preferredVoice = pickDutchVoice(); };
      ensureVoice();
    }

    function speak(text, opts){
      opts = opts || {};
      const interrupt = !!opts.interrupt;
      if (!("speechSynthesis" in window)) return Promise.resolve();

      if (interrupt){
        try{ window.speechSynthesis.cancel(); }catch(e){}
      } else if (speechBusy){
        return new Promise(function(resolve){
          const t = setInterval(function(){
            if (!speechBusy){
              clearInterval(t);
              speak(text, opts).then(resolve);
            }
          }, 50);
        });
      }

      ensureVoice();
      return new Promise(function(resolve){
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "nl-NL";
        if (preferredVoice) u.voice = preferredVoice;
        u.rate = 0.95;
        u.pitch = 1.05;

        speechBusy = true;
        u.onend = function(){ speechBusy = false; resolve(); };
        u.onerror = function(){ speechBusy = false; resolve(); };

        try{ window.speechSynthesis.speak(u); }
        catch(e){ speechBusy = false; resolve(); }
      });
    }

    function sayPrompt(d){ return speak("Zoek de " + wordFor(d) + ".", { interrupt:true }); }
    function sayGood(d){ return speak("Goed zo! Dat is " + wordFor(d) + "!", { interrupt:false }); }
    function sayTryAgain(d){ return speak("Oeps. Zoek de " + wordFor(d) + ".", { interrupt:false }); }
    function sayTeachAndRetryLater(d){
      return speak("Dit is de " + wordFor(d) + ". Ik vraag hem straks nog een keer. Dit is dus de " + wordFor(d) + ".", { interrupt:false });
    }
    function sayLevelUp(){ return speak("Goed gedaan! Volgende level!", { interrupt:false }); }

    function shuffle(arr){
      const a = arr.slice();
      for (let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        const t = a[i]; a[i]=a[j]; a[j]=t;
      }
      return a;
    }

    document.addEventListener("DOMContentLoaded", function(){
      const gameEl = document.getElementById("game");
      const scanArea = document.getElementById("scan-area");
      const titleBadge = document.getElementById("title-badge");
      const levelChip = document.getElementById("level-chip");

      const curtains = document.getElementById("curtains");
      const revealDigit = document.getElementById("reveal-digit");
      const revealMark = document.getElementById("reveal-mark");
      const sparkle = document.getElementById("sparkle");
      const progressEl = document.getElementById("progress");

      // Als je gordijnen.gif langer/korter is: pas dit aan
      const CURTAIN_HIDE_AFTER_OPEN_MS = 950;

      function setScanState(state){
        scanArea.classList.remove("state-neutral","state-scanning","state-correct","state-wrong");
        if (state === "scanning") scanArea.classList.add("state-scanning");
        else if (state === "correct") scanArea.classList.add("state-correct");
        else if (state === "wrong") scanArea.classList.add("state-wrong");
        else scanArea.classList.add("state-neutral");
      }

      function showSparkle(on, glyph){
        if (glyph) sparkle.textContent = glyph;
        sparkle.classList.toggle("show", !!on);
      }

      function curtainsAnimate(on){ curtains.classList.toggle("anim", !!on); }
      function setCurtainsOpen(open){ curtains.classList.toggle("open", !!open); }
      function hideCurtainsLayer(){ curtains.classList.add("hidden"); }
      function showCurtainsLayer(){ curtains.classList.remove("hidden"); }

      function resetCurtainsClosedStill(){
        showCurtainsLayer();
        curtainsAnimate(false);
        setCurtainsOpen(false);
      }

      function openCurtainsAndHide(){
        showCurtainsLayer();
        curtainsAnimate(true);
        requestAnimationFrame(function(){ setCurtainsOpen(true); });

        setTimeout(function(){
          curtainsAnimate(false);  // terug naar still voor volgende keer
          hideCurtainsLayer();     // gif niet zichtbaar meer
        }, CURTAIN_HIDE_AFTER_OPEN_MS);
      }

      function setRevealNeutral(){
        revealDigit.style.backgroundImage = "none";
        revealMark.textContent = "üé≠";
      }
      function setRevealForDigit(d){
        revealDigit.style.backgroundImage = "url('" + DIGIT_IMAGE_PREFIX + d + DIGIT_IMAGE_SUFFIX + "')";
      }

      let pips = [];
      function buildProgress(levelDigits){
        progressEl.innerHTML = "";
        pips = [];
        for (let i=0;i<levelDigits.length;i++){
          const pip = document.createElement("div");
          pip.className = "pip";
          progressEl.appendChild(pip);
          pips.push(pip);
        }
      }
      function updateProgress(levelDigits, mastered){
        for (let i=0;i<levelDigits.length;i++){
          const d = levelDigits[i];
          pips[i].classList.toggle("on", !!mastered[d]);
        }
      }

      function setLevelUI(level){
        gameEl.dataset.level = String(level);
        levelChip.textContent = (level === 1) ? "üå±" : "üöÄ";
      }

      // ===== Game state (alle cijfers langs, fouten komen terug) =====
      let level = 1;
      let levelDigits = [1,2,3,4,5]; // level 1: geen 0
      let bag = shuffle(levelDigits);
      let mastered = {};             // digit -> true
      let reviewQueue = [];          // { digit, dueAt }
      let roundCount = 0;

      let targetDigit = bag.pop();
      let wrongCount = 0;
      let roundActive = true;

      // Touch/recognition
      let currentPoints = [];
      let hasResultForCurrentTouches = false;

      // iOS: prompt kan pas na user gesture
      let promptAttempted = false;
      let audioUnlocked = false;
      function unlockAudioOnce(){
        if (audioUnlocked) return;
        audioUnlocked = true;
        ensureAudio();
        // ook speech engine ‚Äúwakkeren‚Äù (werkt niet altijd, maar helpt)
        try { if ("speechSynthesis" in window) window.speechSynthesis.cancel(); } catch(e){}
      }

      function getDueReview(){
        const dueIdx = [];
        for (let i=0;i<reviewQueue.length;i++){
          if (reviewQueue[i].dueAt <= roundCount) dueIdx.push(i);
        }
        if (dueIdx.length === 0) return null;
        const pickIndex = dueIdx[Math.floor(Math.random()*dueIdx.length)];
        const item = reviewQueue.splice(pickIndex, 1)[0];
        return item.digit;
      }

      function getNextTarget(){
        const dueReview = getDueReview();
        if (dueReview !== null){
          if (bag.length === 0 || Math.random() < 0.35){
            return dueReview;
          } else {
            reviewQueue.push({ digit: dueReview, dueAt: roundCount });
          }
        }
        if (bag.length > 0) return bag.pop();
        if (reviewQueue.length > 0){
          reviewQueue.sort(function(a,b){ return a.dueAt - b.dueAt; });
          return reviewQueue.shift().digit;
        }
        return null;
      }

      function maybeLevelUp(){
        if (level !== 1) return Promise.resolve(false);

        for (let i=0;i<levelDigits.length;i++){
          if (!mastered[levelDigits[i]]) return Promise.resolve(false);
        }
        if (reviewQueue.length > 0) return Promise.resolve(false);
        if (bag.length > 0) return Promise.resolve(false);

        level = 2;
        levelDigits = [0,1,2,3,4,5,6,7,8,9];
        bag = shuffle(levelDigits);
        mastered = {};
        reviewQueue = [];
        roundCount = 0;

        setLevelUI(level);
        buildProgress(levelDigits);
        updateProgress(levelDigits, mastered);

        showSparkle(true, "üéâ");
        return sayLevelUp().then(function(){
          setTimeout(function(){ showSparkle(false); }, 600);
          return true;
        });
      }

      function startRound(nextDigit){
        targetDigit = nextDigit;
        wrongCount = 0;
        roundActive = true;
        hasResultForCurrentTouches = false;

        setScanState("neutral");
        setRevealNeutral();
        showSparkle(false);
        resetCurtainsClosedStill();

        promptAttempted = true;
        sayPrompt(targetDigit);
      }

      function newRound(){
        const next = getNextTarget();
        if (next === null){
          return maybeLevelUp().then(function(didUp){
            if (didUp){
              startRound(getNextTarget());
            } else {
              // level 2 cyclus klaar -> opnieuw
              bag = shuffle(levelDigits);
              mastered = {};
              reviewQueue = [];
              roundCount = 0;
              updateProgress(levelDigits, mastered);
              startRound(getNextTarget());
            }
          });
        }
        startRound(next);
        return Promise.resolve();
      }

      function handleCorrect(){
        if (!roundActive) return;
        roundActive = false;

        setScanState("correct");
        ensureAudio(); sfxGood();

        setRevealForDigit(targetDigit);
        revealMark.textContent = "‚úÖ";
        showSparkle(true, "‚≠ê");
        openCurtainsAndHide();

        mastered[targetDigit] = true;
        updateProgress(levelDigits, mastered);
        roundCount += 1;

        sayGood(targetDigit).then(function(){
          setTimeout(function(){
            showSparkle(false);
            resetCurtainsClosedStill();
            newRound();
          }, 520);
        });
      }

      function handleWrong(){
        if (!roundActive) return;

        wrongCount += 1;
        setScanState("wrong");
        ensureAudio(); sfxBad();

        if (wrongCount < 2){
          showSparkle(true, "üîÅ");
          sayTryAgain(targetDigit).then(function(){
            setTimeout(function(){
              showSparkle(false);
              if (currentPoints.length === 0) setScanState("neutral");
              else setScanState("scanning");
            }, 350);
          });
          return;
        }

        // 2x fout: laat zien + uitleg + later opnieuw
        roundActive = false;

        setRevealForDigit(targetDigit);
        revealMark.textContent = "üëÄ";
        showSparkle(true, "üí°");
        openCurtainsAndHide();

        reviewQueue.push({ digit: targetDigit, dueAt: roundCount + 3 });
        roundCount += 1;

        sayTeachAndRetryLater(targetDigit).then(function(){
          setTimeout(function(){
            showSparkle(false);
            resetCurtainsClosedStill();
            newRound();
          }, 520);
        });
      }

      function getPointsFromTouches(touchList){
        const rect = scanArea.getBoundingClientRect();
        const points = [];
        for (let i=0;i<touchList.length;i++){
          const t = touchList[i];
          const x = t.clientX;
          const y = t.clientY;
          if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom){
            points.push({ x:x, y:y });
          }
        }
        return points;
      }

      function handleTouchEvent(e){
        // belangrijk: hiermee blokkeren we scroll/zoom, maar laten multitouch door
        if (e && e.cancelable) e.preventDefault();

        unlockAudioOnce();

        // als prompt bij openen geblokkeerd was, probeer bij eerste aanraking opnieuw
        if (!promptAttempted){
          promptAttempted = true;
          sayPrompt(targetDigit);
        }

        const touches = e.touches || [];
        currentPoints = getPointsFromTouches(touches);

        if (currentPoints.length === 0){
          hasResultForCurrentTouches = false;
          if (roundActive) setScanState("neutral");
          return;
        }

        if (roundActive) setScanState("scanning");

        if (currentPoints.length !== expectedTouchPoints){
          hasResultForCurrentTouches = false;
          return;
        }

        if (!hasResultForCurrentTouches && roundActive){
          const digit = recognizeDigit(currentPoints);
          if (digit !== null && typeof digit === "number"){
            hasResultForCurrentTouches = true;
            if (digit === targetDigit) handleCorrect();
            else handleWrong();
          }
        }
      }

      // !! niet-passive, zodat preventDefault werkt (tegen zoom)
      ["touchstart","touchmove","touchend","touchcancel"].forEach(function(type){
        scanArea.addEventListener(type, handleTouchEvent, { passive:false });
      });

      // titel: prompt opnieuw (mag interrupt)
      let lastTitleTouch = 0;
      function repeatPrompt(){ sayPrompt(targetDigit); }
      titleBadge.addEventListener("touchstart", function(e){
        if (e && e.cancelable) e.preventDefault();
        lastTitleTouch = Date.now();
        unlockAudioOnce();
        repeatPrompt();
      }, { passive:false });

      titleBadge.addEventListener("click", function(){
        if (Date.now() - lastTitleTouch < 500) return;
        unlockAudioOnce();
        repeatPrompt();
      });

      // init
      setLevelUI(level);
      buildProgress(levelDigits);
      updateProgress(levelDigits, mastered);
      setRevealNeutral();
      resetCurtainsClosedStill();
      showSparkle(false);
      setScanState("neutral");

      promptAttempted = false;

      fetch("calibration.json")
        .then(function(r){ return r.json(); })
        .then(function(data){
          initCalibration(data);
          startRound(getNextTarget());
        })
        .catch(function(){
          startRound(getNextTarget());
        });
    });
  </script>
</body>
</html>
