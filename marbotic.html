<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Marbotic Cijfer Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #222;
      background-color: #f4f4f4;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
    }

    .app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header.top-bar {
      padding: 0.75rem 1rem;
      background: linear-gradient(135deg, #2196f3, #64b5f6);
      color: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }

    .top-bar-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .mode-indicator {
      font-size: 1.3rem;
      font-weight: 700;
    }

    .status {
      font-size: 0.95rem;
      opacity: 0.95;
    }

    main.content {
      flex: 1;
      display: flex;
      flex-direction: row;
      gap: 0.75rem;
      padding: 0.75rem;
    }

    .touch-area {
      flex: 3;
      min-height: 300px;
      background-color: #ffffff;
      border-radius: 1rem;
      box-shadow: 0 3px 8px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      position: relative;
      touch-action: none;
      overflow: hidden;
    }

    .instruction {
      font-size: 1.6rem;
      font-weight: 600;
      text-align: center;
      padding: 0.5rem 1rem;
    }

    .sub-instruction {
      margin-top: 0.5rem;
      font-size: 0.95rem;
      color: #555;
      text-align: center;
    }

    .scan-display {
      text-align: center;
    }

    .scan-label {
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      color: #555;
    }

    .predicted-digit {
      font-size: 6rem;
      font-weight: 800;
      color: #2196f3;
      text-shadow: 0 4px 8px rgba(0,0,0,0.15);
      line-height: 1;
    }

    .scan-result-label {
      margin-top: 0.3rem;
      font-size: 1.1rem;
      color: #555;
    }

    .scan-status {
      margin-top: 0.4rem;
      font-size: 0.95rem;
      color: #777;
    }

    .side-panel {
      flex: 2;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .buttons {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    button {
      font-size: 1rem;
      padding: 0.7rem 0.9rem;
      border-radius: 0.8rem;
      border: none;
      outline: none;
      background: #1976d2;
      color: white;
      font-weight: 600;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      width: 100%;
      cursor: pointer;
      touch-action: manipulation;
    }

    button:active {
      transform: scale(0.98);
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    button.secondary {
      background: #ffffff;
      color: #1976d2;
      border: 2px solid #1976d2;
      box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    }

    button.danger {
      background: #e53935;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }

    .debug-panel {
      background-color: #ffffff;
      border-radius: 0.9rem;
      padding: 0.6rem 0.8rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      font-size: 0.85rem;
    }

    .debug-panel h2 {
      margin: 0 0 0.4rem 0;
      font-size: 0.95rem;
      font-weight: 700;
      color: #333;
    }

    #debugCanvas {
      border: 1px solid #e0e0e0;
      border-radius: 0.5rem;
      width: 100%;
      max-width: 220px;
      display: block;
      margin-bottom: 0.4rem;
      background-color: #fafafa;
    }

    .debug-text {
      font-family: "SF Mono", Menlo, Consolas, monospace;
      white-space: pre-line;
      color: #444;
    }

    .data-section {
      padding: 0.6rem 0.75rem 0.9rem 0.75rem;
      border-top: 1px solid #ddd;
      background-color: #ffffff;
    }

    .data-section label {
      display: block;
      font-size: 0.9rem;
      margin-bottom: 0.3rem;
      color: #333;
    }

    #dataTextarea {
      width: 100%;
      min-height: 160px;
      font-family: "SF Mono", Menlo, Consolas, monospace;
      font-size: 0.85rem;
      padding: 0.4rem;
      border-radius: 0.5rem;
      border: 1px solid #ccc;
      resize: vertical;
    }

    footer {
      padding: 0.4rem 0.9rem 0.7rem 0.9rem;
      font-size: 0.8rem;
      color: #777;
    }

    .hidden {
      display: none !important;
    }

    @media (max-width: 900px) {
      main.content {
        flex-direction: column;
      }

      .side-panel {
        flex-direction: row;
        flex-wrap: wrap;
      }

      .buttons {
        flex: 2;
      }

      .debug-panel {
        flex: 1;
      }

      .predicted-digit {
        font-size: 4.5rem;
      }

      .instruction {
        font-size: 1.4rem;
      }
    }

    @media (max-width: 600px) {
      button {
        font-size: 0.95rem;
        padding: 0.6rem 0.8rem;
      }

      .top-bar-row {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
<div class="app">
  <header class="top-bar">
    <div class="top-bar-row">
      <div class="mode-indicator">
        Modus: <span id="modeLabel">Kalibreren</span>
      </div>
      <div class="status" id="statusLabel">
        Start met kalibreren en leg het cijfer 0 op het scherm.
      </div>
    </div>
  </header>

  <main class="content">
    <section id="touchArea" class="touch-area">
      <div id="calibrateInstruction" class="instruction">
        Leg nu het cijfer 0 op het scherm
      </div>
      <div id="calibrateSubInstruction" class="sub-instruction">
        Raak het scherm alleen met het houten cijfer, geen vingers. De app legt het cijfer automatisch vast.
      </div>

      <div id="scanDisplay" class="scan-display hidden">
        <div class="scan-label">Herkenning</div>
        <div id="predictedDigit" class="predicted-digit">?</div>
        <div id="scanResultLabel" class="scan-result-label">Wachten op drie aanrakingen</div>
        <div id="scanStatusLabel" class="scan-status">Leg een gekalibreerd cijfer op het scherm.</div>
      </div>
    </section>

    <aside class="side-panel">
      <div class="buttons">
        <button id="toCalibrateBtn" class="secondary">Naar kalibreren</button>
        <button id="toScanBtn" disabled>Naar scannen</button>
        <button id="recalibrateBtn">Kalibreren opnieuw</button>
        <button id="resetBtn" class="danger">Wis kalibratie</button>
        <button id="showDataBtn" class="secondary">Toon kalibratiegegevens</button>
      </div>

      <div class="debug-panel">
        <h2>Debug driehoek</h2>
        <canvas id="debugCanvas" width="160" height="160"></canvas>
        <div id="debugText" class="debug-text">
          Nog geen meting.
        </div>
      </div>
    </aside>
  </main>

  <section id="dataSection" class="data-section hidden">
    <label for="dataTextarea">Kalibratiegegevens (JSON) om te kopiëren</label>
    <textarea id="dataTextarea" readonly></textarea>
  </section>

  <footer>
    Tip: zet het scherm van de tablet of telefoon zo vlak mogelijk neer en zorg dat de houten cijfers schoon en droog zijn.
  </footer>
</div>

<script>
  (function () {
    "use strict";

    // Kortere stabilisatieperiode
    const STABLE_TIME_MS = 200;
    const MOVE_TOLERANCE_PX = 25;
    const MATCH_THRESHOLD = 0.35;
    const ORIENTATION_PENALTY = 0.6;
    const LOCAL_STORAGE_KEY = "marboticCalibration";

    const DIGIT_ORDER = ["0","1","2","3","4","5","6","7","8","9"];
    const digitNames = {
      "0": "nul",
      "1": "een",
      "2": "twee",
      "3": "drie",
      "4": "vier",
      "5": "vijf",
      "6": "zes",
      "7": "zeven",
      "8": "acht",
      "9": "negen"
    };

    // UI elements
    const modeLabel = document.getElementById("modeLabel");
    const statusLabel = document.getElementById("statusLabel");
    const touchArea = document.getElementById("touchArea");
    const calibrateInstruction = document.getElementById("calibrateInstruction");
    const calibrateSubInstruction = document.getElementById("calibrateSubInstruction");
    const scanDisplay = document.getElementById("scanDisplay");
    const predictedDigitEl = document.getElementById("predictedDigit");
    const scanResultLabel = document.getElementById("scanResultLabel");
    const scanStatusLabel = document.getElementById("scanStatusLabel");
    const toCalibrateBtn = document.getElementById("toCalibrateBtn");
    const toScanBtn = document.getElementById("toScanBtn");
    const recalibrateBtn = document.getElementById("recalibrateBtn");
    const resetBtn = document.getElementById("resetBtn");
    const showDataBtn = document.getElementById("showDataBtn");
    const dataSection = document.getElementById("dataSection");
    const dataTextarea = document.getElementById("dataTextarea");
    const debugCanvas = document.getElementById("debugCanvas");
    const debugText = document.getElementById("debugText");

    const ctx = debugCanvas.getContext("2d");

    // State
    let mode = "calibrate"; // "calibrate" of "scan"
    let calibration = {};
    let calibrationComplete = false;
    let currentDigitIndex = 0;
    let waitingForRelease = false;
    let stableCandidate = null;
    let stableTimeoutId = null;      // nieuw
    let lastTouchCount = 0;
    let lastPrediction = null;

    function distance(p, q) {
      const dx = p.x - q.x;
      const dy = p.y - q.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function clonePoints(points) {
      return points.map(p => ({ x: p.x, y: p.y, id: p.id }));
    }

    function computeFeatures(points) {
      if (!points || points.length !== 3) {
        return null;
      }
      const p0 = points[0];
      const p1 = points[1];
      const p2 = points[2];

      const centroid = {
        x: (p0.x + p1.x + p2.x) / 3,
        y: (p0.y + p1.y + p2.y) / 3
      };

      const d01 = distance(p0, p1);
      const d12 = distance(p1, p2);
      const d20 = distance(p2, p0);

      const sidesRaw = [d01, d12, d20];
      const maxSide = Math.max(d01, d12, d20) || 1;
      const sidesNorm = sidesRaw.map(v => v / maxSide);
      const sidesSorted = sidesNorm.slice().sort((a, b) => a - b);

      let a = d01;
      let b = d12;
      let c = d20;
      let cosAngle = 0;

      const maxOriginal = Math.max(a, b, c);
      if (maxOriginal === a) {
        cosAngle = ((b * b + c * c - a * a) || 0) / (2 * b * c || 1);
      } else if (maxOriginal === b) {
        cosAngle = ((a * a + c * c - b * b) || 0) / (2 * a * c || 1);
      } else {
        cosAngle = ((a * a + b * b - c * c) || 0) / (2 * a * b || 1);
      }
      if (!Number.isFinite(cosAngle)) {
        cosAngle = 0;
      }

      const cross =
        (p1.x - p0.x) * (p2.y - p0.y) -
        (p1.y - p0.y) * (p2.x - p0.x);
      const orientation = cross >= 0 ? 1 : -1;

      return {
        sides: sidesSorted,
        orientation: orientation,
        cosAngle: cosAngle,
        centroid: centroid
      };
    }

    function compareFeatures(f1, f2) {
      if (!f1 || !f2) {
        return Number.POSITIVE_INFINITY;
      }
      const s1 = f1.sides || [0, 0, 0];
      const s2 = f2.sides || [0, 0, 0];
      const d0 = s1[0] - s2[0];
      const d1 = s1[1] - s2[1];
      const d2 = s1[2] - s2[2];
      const dCos = (f1.cosAngle || 0) - (f2.cosAngle || 0);
      let distSq = d0 * d0 + d1 * d1 + d2 * d2 + dCos * dCos;
      let dist = Math.sqrt(distSq);
      if ((f1.orientation || 0) !== (f2.orientation || 0)) {
        dist += ORIENTATION_PENALTY;
      }
      return dist;
    }

    function findBestMatch(features, calibrationData) {
      let bestDigit = null;
      let bestDist = Number.POSITIVE_INFINITY;

      DIGIT_ORDER.forEach(d => {
        const entry = calibrationData[d];
        if (!entry || !entry.features) {
          return;
        }
        const dist = compareFeatures(features, entry.features);
        if (dist < bestDist) {
          bestDist = dist;
          bestDigit = d;
        }
      });

      return { digit: bestDigit, distance: bestDist };
    }

    function drawTriangle(points) {
      ctx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
      if (!points || points.length !== 3) {
        return;
      }
      const xs = points.map(p => p.x);
      const ys = points.map(p => p.y);
      const minX = Math.min.apply(null, xs);
      const maxX = Math.max.apply(null, xs);
      const minY = Math.min.apply(null, ys);
      const maxY = Math.max.apply(null, ys);

      const width = maxX - minX || 1;
      const height = maxY - minY || 1;
      const padding = 10;
      const scale = Math.min(
        (debugCanvas.width - 2 * padding) / width,
        (debugCanvas.height - 2 * padding) / height
      );

      const cx = debugCanvas.width / 2;
      const cy = debugCanvas.height / 2;
      const midX = (minX + maxX) / 2;
      const midY = (minY + maxY) / 2;

      const mapped = points.map(p => {
        return {
          x: (p.x - midX) * scale + cx,
          y: (p.y - midY) * scale + cy
        };
      });

      ctx.beginPath();
      ctx.moveTo(mapped[0].x, mapped[0].y);
      ctx.lineTo(mapped[1].x, mapped[1].y);
      ctx.lineTo(mapped[2].x, mapped[2].y);
      ctx.closePath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#1976d2";
      ctx.stroke();

      ctx.fillStyle = "#ef6c00";
      mapped.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function updateDebugPanel(points, features, matchInfo) {
      drawTriangle(points);

      let text = "";
      if (features) {
        const s = features.sides || [0, 0, 0];
        text += "Zijden (genormaliseerd):\n";
        text += "  " + s.map(v => v.toFixed(3)).join("  ") + "\n\n";
        text += "Oriëntatie: " + (features.orientation || 0) + "\n";
        text += "cos(hoek): " + (features.cosAngle || 0).toFixed(3) + "\n";
      } else {
        text += "Nog geen geldige driehoek.\n";
      }

      if (matchInfo && matchInfo.digit != null) {
        text += "\nBeste match: " + matchInfo.digit +
          "  (afstand " + matchInfo.distance.toFixed(3) + ")";
      } else if (mode === "scan") {
        text += "\nBeste match: geen";
      }

      debugText.textContent = text;
    }

    function speakDigit(digitStr) {
      const name = digitNames[digitStr];
      if (!name) {
        return;
      }
      if (!("speechSynthesis" in window) || typeof window.SpeechSynthesisUtterance === "undefined") {
        return;
      }
      try {
        window.speechSynthesis.cancel();
        const utter = new window.SpeechSynthesisUtterance(name);
        utter.lang = "nl-NL";
        utter.rate = 1;
        window.speechSynthesis.speak(utter);
      } catch (e) {
        // Stil falen bij problemen met spraak
      }
    }

    function safeLoadCalibration() {
      try {
        const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (!stored) {
          return;
        }
        const parsed = JSON.parse(stored);
        let valid = true;
        DIGIT_ORDER.forEach(d => {
          if (!parsed || !parsed[d] || !parsed[d].features) {
            valid = false;
          }
        });
        if (valid) {
          calibration = parsed;
          calibrationComplete = true;
          toScanBtn.disabled = false;
          statusLabel.textContent = "Kalibratie geladen uit opslag. Je kunt naar scannen gaan of opnieuw kalibreren.";
        }
      } catch (e) {
        // Als opslag niet werkt, gewoon verder
      }
    }

    function safeSaveCalibration() {
      try {
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(calibration));
      } catch (e) {
        // Geen harde fout bij opslag
      }
    }

    function refreshDataTextarea() {
      dataTextarea.value = JSON.stringify(calibration, null, 2);
    }

    function updateModeUI() {
      modeLabel.textContent = mode === "calibrate" ? "Kalibreren" : "Scannen";

      if (mode === "calibrate") {
        calibrateInstruction.classList.remove("hidden");
        calibrateSubInstruction.classList.remove("hidden");
        scanDisplay.classList.add("hidden");
        toCalibrateBtn.classList.add("secondary");
        toScanBtn.classList.remove("secondary");
      } else {
        calibrateInstruction.classList.add("hidden");
        calibrateSubInstruction.classList.add("hidden");
        scanDisplay.classList.remove("hidden");
        toCalibrateBtn.classList.remove("secondary");
        toScanBtn.classList.add("secondary");
      }
    }

    function setCalibrateInstruction() {
      const digitStr = DIGIT_ORDER[currentDigitIndex];
      calibrateInstruction.textContent = "Leg nu het cijfer " + digitStr + " op het scherm";
      calibrateSubInstruction.textContent = "Raak het scherm alleen met het houten cijfer. De app legt het cijfer automatisch vast.";
      statusLabel.textContent = "Kalibreren: wacht op drie stabiele aanrakingen voor cijfer " + digitStr + ".";
    }

    function markDigitCaptured(digitStr) {
      calibrateInstruction.textContent = "Cijfer " + digitStr + " vastgelegd, haal het cijfer van het scherm.";
      calibrateSubInstruction.textContent = "Wacht tot het scherm geen aanrakingen meer heeft.";
      statusLabel.textContent = "Cijfer " + digitStr + " vastgelegd. Wacht tot het scherm vrij is.";
    }

    function checkCalibrationComplete() {
      return DIGIT_ORDER.every(d => calibration[d] && calibration[d].features);
    }

    function finishCalibrationIfReady() {
      if (checkCalibrationComplete()) {
        calibrationComplete = true;
        toScanBtn.disabled = false;
        statusLabel.textContent = "Alle cijfers zijn gekalibreerd. Je kunt nu naar scannen gaan.";
        safeSaveCalibration();
        refreshDataTextarea();
      }
    }

    function advanceToNextDigit() {
      if (currentDigitIndex < DIGIT_ORDER.length - 1) {
        currentDigitIndex += 1;
        setCalibrateInstruction();
      } else {
        calibrateInstruction.textContent = "Kalibratie compleet.";
        calibrateSubInstruction.textContent = "Je kunt nu naar scannen gaan of opnieuw kalibreren.";
        statusLabel.textContent = "Kalibratie voltooid voor alle cijfers.";
      }
    }

    function clearStableCandidate() {
      stableCandidate = null;
      if (stableTimeoutId !== null) {
        clearTimeout(stableTimeoutId);
        stableTimeoutId = null;
      }
    }

    function resetCalibrationState(clearStorage) {
      calibration = {};
      calibrationComplete = false;
      currentDigitIndex = 0;
      waitingForRelease = false;
      clearStableCandidate();
      lastTouchCount = 0;
      lastPrediction = null;
      toScanBtn.disabled = true;
      predictedDigitEl.textContent = "?";
      scanResultLabel.textContent = "Wachten op drie aanrakingen";
      scanStatusLabel.textContent = "Leg een gekalibreerd cijfer op het scherm.";
      setCalibrateInstruction();
      updateDebugPanel(null, null, null);
      if (clearStorage) {
        try {
          localStorage.removeItem(LOCAL_STORAGE_KEY);
        } catch (e) {
        }
        refreshDataTextarea();
      }
    }

    function setPrediction(digitStr, distance) {
      if (!digitStr) {
        predictedDigitEl.textContent = "?";
        scanResultLabel.textContent = "Onbekend";
        scanStatusLabel.textContent = "De vorm lijkt niet op een gekalibreerd cijfer.";
        lastPrediction = null;
        return;
      }

      predictedDigitEl.textContent = digitStr;
      scanResultLabel.textContent = "Herkenning: " + digitStr;
      scanStatusLabel.textContent = "Afstand tot kalibratie: " + distance.toFixed(3);

      if (lastPrediction !== digitStr) {
        lastPrediction = digitStr;
        speakDigit(digitStr);
      }
    }

    function clearPrediction() {
      predictedDigitEl.textContent = "?";
      scanResultLabel.textContent = "Wachten op drie aanrakingen";
      scanStatusLabel.textContent = "Leg een gekalibreerd cijfer op het scherm.";
      lastPrediction = null;
    }

    function touchesToPoints(touchList) {
      const arr = [];
      for (let i = 0; i < touchList.length; i++) {
        const t = touchList.item(i);
        arr.push({
          id: t.identifier,
          x: t.clientX,
          y: t.clientY
        });
      }
      return arr;
    }

    function idsFromPoints(points) {
      return points.map(p => p.id).sort();
    }

    function sameIds(pointsA, pointsB) {
      if (!pointsA || !pointsB || pointsA.length !== pointsB.length) {
        return false;
      }
      const idsA = idsFromPoints(pointsA);
      const idsB = idsFromPoints(pointsB);
      for (let i = 0; i < idsA.length; i++) {
        if (idsA[i] !== idsB[i]) {
          return false;
        }
      }
      return true;
    }

    function maxMovement(pointsNow, pointsOrigin) {
      if (!pointsNow || !pointsOrigin || pointsNow.length !== pointsOrigin.length) {
        return Number.POSITIVE_INFINITY;
      }
      let maxMove = 0;
      for (let i = 0; i < pointsNow.length; i++) {
        const pNow = pointsNow[i];
        let origin = pointsOrigin.find(p => p.id === pNow.id);
        if (!origin) {
          origin = pointsOrigin[i];
        }
        const d = distance(pNow, origin);
        if (d > maxMove) {
          maxMove = d;
        }
      }
      return maxMove;
    }

    function handleStableThreePoints(points) {
      const purePoints = points.map(p => ({ x: p.x, y: p.y }));
      const features = computeFeatures(purePoints);

      if (mode === "calibrate") {
        if (calibrationComplete) {
          return;
        }
        const digitStr = DIGIT_ORDER[currentDigitIndex];
        calibration[digitStr] = {
          digit: parseInt(digitStr, 10),
          points: purePoints,
          features: features
        };
        markDigitCaptured(digitStr);
        waitingForRelease = true;
        updateDebugPanel(purePoints, features, null);
        finishCalibrationIfReady();
        refreshDataTextarea();
      } else if (mode === "scan") {
        if (!calibrationComplete) {
          statusLabel.textContent = "Scannen is niet beschikbaar. Kalibreer eerst alle cijfers.";
          return;
        }
        const match = findBestMatch(features, calibration);
        let chosenDigit = null;
        if (match.digit != null && match.distance <= MATCH_THRESHOLD) {
          chosenDigit = match.digit;
          statusLabel.textContent = "Cijfer " + chosenDigit + " herkend.";
        } else {
          statusLabel.textContent = "Vorm komt niet overeen met kalibratie.";
        }
        setPrediction(chosenDigit, match.distance || 0);
        updateDebugPanel(purePoints, features, match);
      }
    }

    function scheduleStableCheck() {
      if (stableTimeoutId !== null) {
        clearTimeout(stableTimeoutId);
      }
      stableTimeoutId = setTimeout(function () {
        if (!stableCandidate || stableCandidate.triggered) {
          return;
        }
        if (lastTouchCount !== 3) {
          return;
        }
        const move = maxMovement(stableCandidate.lastPoints, stableCandidate.originPoints);
        if (move > MOVE_TOLERANCE_PX) {
          return;
        }
        stableCandidate.triggered = true;
        handleStableThreePoints(stableCandidate.lastPoints);
      }, STABLE_TIME_MS);
    }

    function processTouches(touches) {
      const now = performance.now();
      const count = touches.length;
      lastTouchCount = count;

      if (mode === "calibrate") {
        if (waitingForRelease) {
          if (count === 0) {
            waitingForRelease = false;
            if (!calibrationComplete) {
              advanceToNextDigit();
            }
          }
          return;
        }
        if (calibrationComplete) {
          return;
        }
      } else if (mode === "scan") {
        if (!calibrationComplete) {
          clearPrediction();
        }
      }

      if (count !== 3) {
        // minder dan drie of meer dan drie aanrakingen, dan geen meting
        clearStableCandidate();
        if (mode === "scan" && count === 0) {
          clearPrediction();
        }
        return;
      }

      // drie aanrakingen
      if (!stableCandidate || !sameIds(touches, stableCandidate.originPoints)) {
        stableCandidate = {
          originPoints: clonePoints(touches),
          startTime: now,
          lastPoints: clonePoints(touches),
          triggered: false
        };
        if (mode === "scan") {
          scanStatusLabel.textContent = "Metingen worden gestabiliseerd.";
        } else {
          statusLabel.textContent = "Metingen worden gestabiliseerd voor dit cijfer.";
        }
        scheduleStableCheck();
        return;
      }

      // zelfde aanrakingen als eerder
      stableCandidate.lastPoints = clonePoints(touches);
      const move = maxMovement(touches, stableCandidate.originPoints);
      if (move > MOVE_TOLERANCE_PX) {
        // opnieuw beginnen als het cijfer echt verschoven is
        stableCandidate = {
          originPoints: clonePoints(touches),
          startTime: now,
          lastPoints: clonePoints(touches),
          triggered: false
        };
        scheduleStableCheck();
        return;
      }

      // extra kans om de meting af te ronden als er toch beweging is
      if (!stableCandidate.triggered && now - stableCandidate.startTime >= STABLE_TIME_MS) {
        stableCandidate.triggered = true;
        handleStableThreePoints(touches);
      }
    }

    function onTouchChange(evt) {
      if (evt.touches && evt.touches.length > 0) {
        evt.preventDefault();
      }
      const touches = touchesToPoints(evt.touches);
      processTouches(touches);
    }

    function onTouchEndOrCancel(evt) {
      if (evt.touches && evt.touches.length > 0) {
        evt.preventDefault();
      }
      const touches = touchesToPoints(evt.touches);
      processTouches(touches);
    }

    toCalibrateBtn.addEventListener("click", function () {
      mode = "calibrate";
      clearStableCandidate();
      updateModeUI();
      if (!calibrationComplete) {
        setCalibrateInstruction();
      } else {
        statusLabel.textContent = "Je zit in kalibreer modus. Je kunt opnieuw kalibreren of naar scannen gaan.";
      }
    });

    toScanBtn.addEventListener("click", function () {
      if (!calibrationComplete) {
        statusLabel.textContent = "Scannen is niet beschikbaar. Kalibreer eerst alle cijfers.";
        return;
      }
      mode = "scan";
      clearStableCandidate();
      updateModeUI();
      clearPrediction();
      statusLabel.textContent = "Scan modus. Leg een gekalibreerd cijfer met drie contactpunten op het scherm.";
    });

    recalibrateBtn.addEventListener("click", function () {
      resetCalibrationState(false);
      statusLabel.textContent = "Kalibratie opnieuw gestart. Leg het cijfer 0 op het scherm.";
      if (mode !== "calibrate") {
        mode = "calibrate";
        updateModeUI();
      }
    });

    resetBtn.addEventListener("click", function () {
      resetCalibrationState(true);
      statusLabel.textContent = "Kalibratie gewist. Start opnieuw bij cijfer 0.";
      if (mode !== "calibrate") {
        mode = "calibrate";
        updateModeUI();
      }
    });

    showDataBtn.addEventListener("click", function () {
      const willShow = dataSection.classList.contains("hidden");
      if (willShow) {
        refreshDataTextarea();
        dataSection.classList.remove("hidden");
        showDataBtn.textContent = "Verberg kalibratiegegevens";
      } else {
        dataSection.classList.add("hidden");
        showDataBtn.textContent = "Toon kalibratiegegevens";
      }
    });

    touchArea.addEventListener("touchstart", onTouchChange, { passive: false });
    touchArea.addEventListener("touchmove", onTouchChange, { passive: false });
    touchArea.addEventListener("touchend", onTouchEndOrCancel, { passive: false });
    touchArea.addEventListener("touchcancel", onTouchEndOrCancel, { passive: false });

    resetCalibrationState(false);
    safeLoadCalibration();
    updateModeUI();
    if (calibrationComplete) {
      refreshDataTextarea();
    }
  })();
</script>
</body>
</html>
